<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="icon" type="image/png" sizes="16x16" href="/images/me.jpg">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="博弈模板，包括：组合游戏基本概念，Bash+Nim，SG函数和各自的例题">
<meta property="og:type" content="article">
<meta property="og:title" content="博弈">
<meta property="og:url" content="http://example.com/2025/09/17/%E5%8D%9A%E5%BC%88/index.html">
<meta property="og:site_name" content="zerocloud01">
<meta property="og:description" content="博弈模板，包括：组合游戏基本概念，Bash+Nim，SG函数和各自的例题">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-09-17T14:22:23.000Z">
<meta property="article:modified_time" content="2025-09-18T07:00:14.888Z">
<meta property="article:author" content="零云Y">
<meta property="article:tag" content="ACM">
<meta property="article:tag" content="博弈">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2025/09/17/%E5%8D%9A%E5%BC%88/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/09/17/%E5%8D%9A%E5%BC%88/","path":"2025/09/17/博弈/","title":"博弈"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>博弈 | zerocloud01</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">zerocloud01</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F"><span class="nav-number">1.</span> <span class="nav-text">组合游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%BE%81"><span class="nav-number">1.1.</span> <span class="nav-text">特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bash%E6%B8%B8%E6%88%8F"><span class="nav-number">2.</span> <span class="nav-text">Bash游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E9%9B%86%E5%90%88%EF%BC%9A"><span class="nav-number">2.1.</span> <span class="nav-text">状态集合：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PN%E6%80%81"><span class="nav-number">2.2.</span> <span class="nav-text">PN态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E6%99%AE%E9%80%82%EF%BC%89%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">（普适）解题方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nim%E6%B8%B8%E6%88%8F"><span class="nav-number">3.</span> <span class="nav-text">Nim游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#P-N%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">P-N分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">3.2.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SG%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">SG函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E6%B8%B8%E6%88%8F"><span class="nav-number">4.1.</span> <span class="nav-text">图游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SG%E5%87%BD%E6%95%B0-1"><span class="nav-number">4.2.</span> <span class="nav-text">SG函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SG%E5%87%BD%E6%95%B0%E4%B8%8EPN%E5%85%B3%E7%B3%BB"><span class="nav-number">4.3.</span> <span class="nav-text">SG函数与PN关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F%E7%9A%84%E5%92%8C"><span class="nav-number">5.</span> <span class="nav-text">组合游戏的和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%9A%84%E5%92%8C"><span class="nav-number">5.1.</span> <span class="nav-text">图游戏的和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SG%E5%AE%9A%E7%90%86"><span class="nav-number">5.2.</span> <span class="nav-text">SG定理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E8%AE%BA"><span class="nav-number">5.3.</span> <span class="nav-text">推论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#code"><span class="nav-number">5.4.</span> <span class="nav-text">code</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-number">6.</span> <span class="nav-text">题目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8F%E8%BD%AC%E7%A7%BB"><span class="nav-number">6.1.</span> <span class="nav-text">组合游戏转移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E8%BD%AC%E7%A7%BB%E6%B1%82%E6%9C%80%E5%80%BC"><span class="nav-number">6.1.1.</span> <span class="nav-text">递归转移求最值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E8%BD%AC%E7%A7%BB"><span class="nav-number">6.1.2.</span> <span class="nav-text">枚举转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dp%E6%89%93%E8%A1%A8"><span class="nav-number">6.1.3.</span> <span class="nav-text">dp打表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nim%E5%8F%98%E4%BD%93"><span class="nav-number">6.1.4.</span> <span class="nav-text">Nim变体</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SG%E5%87%BD%E6%95%B0-2"><span class="nav-number">6.2.</span> <span class="nav-text">SG函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E9%A2%98"><span class="nav-number">6.2.1.</span> <span class="nav-text">模板题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E5%BE%8B%E4%BC%98%E5%8C%96sg%E9%80%9F%E5%BA%A6%EF%BC%88%E5%87%8F%E5%B0%91%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-number">6.2.2.</span> <span class="nav-text">使用规律优化sg速度（减少递归）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%A3%82%E6%B8%B8%E6%88%8F%EF%BC%88sg%E6%89%93%E8%A1%A8%E6%89%BE%E8%A7%84%E5%BE%8B%EF%BC%89"><span class="nav-number">6.2.3.</span> <span class="nav-text">分裂游戏（sg打表找规律）</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="零云Y"
      src="/images/me.jpg">
  <p class="site-author-name" itemprop="name">零云Y</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zerocloud01" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zerocloud01" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/09/17/%E5%8D%9A%E5%BC%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.jpg">
      <meta itemprop="name" content="零云Y">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zerocloud01">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="博弈 | zerocloud01">
      <meta itemprop="description" content="博弈模板，包括：组合游戏基本概念，Bash+Nim，SG函数和各自的例题">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          博弈
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-17 22:22:23" itemprop="dateCreated datePublished" datetime="2025-09-17T22:22:23+08:00">2025-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-18 15:00:14" itemprop="dateModified" datetime="2025-09-18T15:00:14+08:00">2025-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ACM/" itemprop="url" rel="index"><span itemprop="name">ACM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ACM/%E5%8D%9A%E5%BC%88/" itemprop="url" rel="index"><span itemprop="name">博弈</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
</div>

            <div class="post-description">博弈模板，包括：组合游戏基本概念，Bash+Nim，SG函数和各自的例题</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><strong>概念：</strong> 博弈论是研究具有斗争或竞争性性质现象的数学理论和方法。</p>
<p>假设玩家的集合是 $ N $，第 $ i $ 个玩家的策略集合是 $ \sum $ ，游戏的结果集合为 $ \Gamma $，关于每个玩家使用不同的策略，游戏产生对应的结果，即 </p>
<p>$$<br>\prod_{i&#x3D;1}^{n} \left(\sum_{j&#x3D;1}^{i} a_j \right) \longrightarrow \Gamma<br>$$</p>
<h2 id="组合游戏"><a href="#组合游戏" class="headerlink" title="组合游戏"></a>组合游戏</h2><blockquote>
<p>博弈的子集</p>
</blockquote>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>两个玩家</li>
<li>一个状态集合</li>
<li>游戏规则是指明玩家在一个状态可以转移到其他状态</li>
<li>玩家轮流进行移动</li>
<li>如果当前处于某个状态，玩家根据规则无法移动，游戏结束。</li>
<li>（<strong>大部分时候</strong>）无论玩家如何选择，游戏都会在有限步内结束。</li>
</ul>
<p><strong>可以将组合游戏理解为有向无环图</strong></p>
<h2 id="Bash游戏"><a href="#Bash游戏" class="headerlink" title="Bash游戏"></a>Bash游戏</h2><p>在 $N$ 堆石子中轮流取 $[1,M]$ 个，谁不能取输。</p>
<blockquote>
<p>结论：当 $N &#x3D; k \cdot (M+1)$ A输，否则A赢</p>
</blockquote>
<h3 id="状态集合："><a href="#状态集合：" class="headerlink" title="状态集合："></a>状态集合：</h3><p>$S &#x3D; {0,1,2,\ldots,N}$，$i\rightarrow$ 当前剩 $i$ 个石子</p>
<h3 id="PN态"><a href="#PN态" class="headerlink" title="PN态"></a>PN态</h3><p><strong>P状态：</strong></p>
<ul>
<li>privious position</li>
<li>走到该状态的玩家胜利（离开失败）</li>
<li><strong>不能</strong>走到 <strong>P状态</strong> 的为P状态</li>
</ul>
<p><strong>N状态：</strong></p>
<ul>
<li>nest position</li>
<li>离开该状态的玩家胜利</li>
<li><strong>可以</strong>走到 <strong>P状态</strong> 的为 N状态</li>
</ul>
<p><u>根据结束状态（无法走到其他状态位置）为 P 或 N来反向转移</u></p>
<h3 id="（普适）解题方法"><a href="#（普适）解题方法" class="headerlink" title="（普适）解题方法"></a>（普适）解题方法</h3><ul>
<li>打表，找规律（DP，搜索）</li>
<li><code>guess</code>，猜结论</li>
<li>证明（理由PN态）</li>
</ul>
<h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><p>有 $N$ 堆石子，第 $i$ 堆有 $a_i$ 个。轮流取，每次取<strong>一堆</strong>中的<strong>至少一个</strong>，不能取的失败。</p>
<h3 id="P-N分析"><a href="#P-N分析" class="headerlink" title="P-N分析"></a>P-N分析</h3><blockquote>
<p>默认 $x_1 \ge x_2 \ge x_3 \ge \cdots \ge x_n$</p>
</blockquote>
<table>
<thead>
<tr>
<th>n</th>
<th align="center">x</th>
<th>P-N</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td align="center"></td>
<td>P</td>
</tr>
<tr>
<td>1</td>
<td align="center">$x$</td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td align="center">$x_1 &#x3D; x_2$</br>$x_1 \ne x_2$</td>
<td>P</br>N</td>
</tr>
<tr>
<td>3</td>
<td align="center">$\ldots$</td>
<td>$\ldots$</td>
</tr>
</tbody></table>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>$x_1 \oplus x_2 \oplus x_3 \oplus \ldots \oplus x_n &#x3D; 0$ <strong>P态</strong></li>
<li>$x_1 \oplus x_2 \oplus x_3 \oplus \ldots \oplus x_n &gt; 0$ <strong>N态</strong></li>
</ul>
<p><strong>推导</strong><br>对于 $x_1 \oplus x_2 \oplus x_3 \oplus \ldots \oplus x_n &#x3D; 0$，一次操作后不可能保持 $&#x3D;0$，必然变为 $&gt; 0$。<br>而对于 $x_1 \oplus x_2 \oplus x_3 \oplus \ldots \oplus x_n &gt; 0$，只需让存有最高位 $1$ 的数，减去其他1组成的数，异或和就将变为 $0$</p>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><h3 id="图游戏"><a href="#图游戏" class="headerlink" title="图游戏"></a>图游戏</h3><p><strong>图游戏是一种组合游戏的抽象描述</strong><br>给定一个有向图 $G &#x3D; (V,E )$，$V$ 是非空点集，$E$ 是有向边集。两个人在图 $G$ 上进行游戏。从起始节点 $x_0$ 出发，轮流移动。每一轮当前玩家可以从当前节点 $x$ 按照邮箱边集移动到下一个节点，把 $x$ 可以一步移动到的节点集合记为 $F(x)$。如果 $F(x)$ 为空，则 $x$ 为终止结点，此时玩家不能移动，游戏结束。</p>
<blockquote>
<p>只讨论无环，且在有限次内终止的情况（否则无意义）</p>
</blockquote>
<h3 id="SG函数-1"><a href="#SG函数-1" class="headerlink" title="SG函数"></a>SG函数</h3><p>定义有向无环图 $G &#x3D; (V,E)$ 的SG函数是一个结点集 $V$ 到非负整数 $Z \ge 0$ 的映射。</p>
<p>$g: V \rightarrow Z_{\ge 0}$，满足$\quad g(x) &#x3D; mex{g(x) | y \in F(x)}$</p>
<h3 id="SG函数与PN关系"><a href="#SG函数与PN关系" class="headerlink" title="SG函数与PN关系"></a>SG函数与PN关系</h3><ul>
<li>$x$ 为P态当且仅当 $g(x) &#x3D; 0$</li>
<li>$x$ 为N态当且仅当 $g(x) &gt; 0$</li>
</ul>
<h2 id="组合游戏的和"><a href="#组合游戏的和" class="headerlink" title="组合游戏的和"></a>组合游戏的和</h2><p>给定多个组合游戏，可以用如下方式把他们进行组合。每个游戏都有一个初始状态，每次当前玩家可以选择一个游戏，并按照该游戏的规则移动一次，如果轮到当前玩家时，所有游戏都不能移动，则玩家输（正常规则）。称这个新的组合游戏为这些</p>
<blockquote>
<p>nim游戏就可以看成若干个游戏的和</p>
</blockquote>
<h3 id="图游戏的和"><a href="#图游戏的和" class="headerlink" title="图游戏的和"></a>图游戏的和</h3><p>假设给定 $n$ 个邮箱无换图 $G_i(V_i,E_i)$，则它们的图游戏的和 $G(V,E)$，满足</p>
<ul>
<li>$V &#x3D; V_1 \times V_2 \times V_3 \times \ldots \times V_n$<blockquote>
<p>笛卡尔乘积是指在数学中，两个集合 $X$ 和 $Y$ 的笛卡尔积（Cartesian product），又称直积，表示为 $X \times Y$，第一个对象是 $X$ 的成员而第二个对象是 $Y$ 的所有可能有序对的其中一个成员</p>
</blockquote>
</li>
<li>结点 $x &#x3D; (x_1,x_2,\ldots,x_n)$ 一步能到 $F(x) &#x3D; U_{i&#x3D;1}^n{(x_1,x_2,\ldots,y_i, \ldots x_n) | y_i \in F_i(x_i)}$<blockquote>
<p>$x_i$ 走向 $y_i$。</p>
</blockquote>
</li>
</ul>
<p>记 $G$ 为 $G_1 + G_2 + \ldots + G_n$。</p>
<h3 id="SG定理"><a href="#SG定理" class="headerlink" title="SG定理"></a>SG定理</h3><p>假设有 $n$ 个组合游戏 $G_1,G_2,\ldots,G_n$，记 $g_i$ 为第 $i(1 \le i \le n)$ 个组合游戏的SG函数，则它们的和 $G &#x3D; G_1+G_2+\ldots +G_N$的SG函数。<br>$g(x) &#x3D; g((x_1,x_2,\ldots)) &#x3D; g(x_1) \oplus g(x_2) \oplus \ldots g_n(x_n)$</p>
<h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><p>假设 $G &#x3D; G_1 + G_2 + \ldots + G_n$</p>
<ul>
<li>$x &#x3D; (x_1,x_2,\ldots,x_n)$ 是 P 态当且仅当 $g(x_1) \oplus g(x_2) \oplus \ldots g_n(x_n) &#x3D; 0$</li>
<li>$x &#x3D; (x_1,x_2,\ldots,x_n)$ 是 N 态当且仅当 $g(x_1) \oplus g(x_2) \oplus \ldots g_n(x_n) &gt; 0$</li>
</ul>
<p><strong>sg的相较比较PN态，优点在于：</strong><b style="color: red"> 可以求多个游戏的组合 </b></p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sg</span><span class="params">(<span class="type">int</span> p)</span><span class="comment">// 记忆化搜索求sg</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// if(p == 0)	return 0;</span></span><br><span class="line">	<span class="keyword">if</span>(sg[p] != <span class="number">-1</span>)	<span class="keyword">return</span> sg[p];</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : a[p])	st.<span class="built_in">insert</span>(<span class="built_in">get_sg</span>(i));</span><br><span class="line">	<span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">count</span>(mex))	<span class="keyword">return</span> (sg[p] = mex);</span><br><span class="line">		mex ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="组合游戏转移"><a href="#组合游戏转移" class="headerlink" title="组合游戏转移"></a>组合游戏转移</h3><h4 id="递归转移求最值"><a href="#递归转移求最值" class="headerlink" title="递归转移求最值"></a>递归转移求最值</h4><p><strong>题面</strong><br>设计师们想出了一个名为“Rake It In”的新简单游戏。两个玩家，Alice和Bob，最初选择一个整数 $k$ 并初始化一个分数指示器。创建一个 $4 \times 4$ 的棋盘，棋盘上有 $16$ 个值。从玩家 Alice 开始，一轮中的每个玩家选择棋盘的 $2 \times 2$ 区域，将该区域中的值的总和添加到得分指示器，然后将这四个值逆时针旋转 $90$ 度。</p>
<p>在总共 $2k$ 轮之后，每个玩家做了 $k$ 次决定。 Alice的最终目标是最大化最终得分。然而对于 Bob 来说，他的目标是最小化最终得分。<br><strong>sloution</strong><br>对于 $Alice$</p>
<ul>
<li>需要保证答案最大</li>
<li>每步选择最大矩形，不能保证答案最大（不能贪心）</li>
<li>所以现需要保证每次操作后，后续操作尽可能<strong>不小</strong>,也就是尽可能大<br>$Bob$同理</li>
</ul>
<p><strong>如果 $k &#x3D; 1$ :</strong><br>A 会给 B 传入 $9$ 种矩形，且加上小矩形的和</p>
<p>然后 B 会从<strong>每个矩形</strong>中选择一个最小值返回</p>
<p>A 最终会选择 小矩形和 $+$ B返回值最大的结果</p>
<p><strong>如果 $k \ge 2$：</strong><br>那么就是重复多次上述步骤，只是每次 B 会选择小矩形 $+$ A返回值 最小的结果</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[x][y] + a[x<span class="number">+1</span>][y] + a[x][y<span class="number">+1</span>] + a[x<span class="number">+1</span>][y<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = a[x][y];</span><br><span class="line">	a[x][y] = a[x][y<span class="number">+1</span>];</span><br><span class="line">	a[x][y<span class="number">+1</span>] = a[x<span class="number">+1</span>][y<span class="number">+1</span>];</span><br><span class="line">	a[x<span class="number">+1</span>][y<span class="number">+1</span>] = a[x<span class="number">+1</span>][y];</span><br><span class="line">	a[x<span class="number">+1</span>][y] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rmove</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = a[x][y];</span><br><span class="line">	a[x][y] = a[x<span class="number">+1</span>][y];</span><br><span class="line">	a[x<span class="number">+1</span>][y] = a[x<span class="number">+1</span>][y<span class="number">+1</span>];</span><br><span class="line">	a[x<span class="number">+1</span>][y<span class="number">+1</span>] = a[x][y<span class="number">+1</span>];</span><br><span class="line">	a[x][y<span class="number">+1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; k*<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res = (p&amp;<span class="number">1</span> ? <span class="number">0</span> : M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = <span class="built_in">get</span>(i,j);</span><br><span class="line">			<span class="built_in">move</span>(i,j);</span><br><span class="line">			res = (p&amp;<span class="number">1</span> ? <span class="built_in">max</span>(res,tmp+<span class="built_in">dfs</span>(p<span class="number">+1</span>)) : <span class="built_in">min</span>(res,tmp+<span class="built_in">dfs</span>(p<span class="number">+1</span>)));</span><br><span class="line">			<span class="built_in">rmove</span>(i,j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;++j)	cin &gt;&gt; a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举转移"><a href="#枚举转移" class="headerlink" title="枚举转移"></a>枚举转移</h4><p><strong>题面</strong><br>一串由0~9组成的数字，可以进行两个操作：<br>1、把其中一个数变为<strong>比它小</strong>的数；<br>2、把其中一个数字0及其右边的所以数字删除。</p>
<p>两人轮流进行操作，最后把所以数字删除的人获胜，问前者胜还是后者胜。<br><strong>sloution</strong><br>有 $\sum_{i&#x3D;1}^{6}(10^i)$ 种数字，若是使用 <code>dfs</code>或者说递归，每个状态都有$1\sim 9$条分支，且还是字符串形式，很容易 <code>TLE</code>。</p>
<p>但若是使用<strong>递推</strong>，只需要 $\sum_{i&#x3D;1}^{6}(10^i)$ 次。</p>
<p><strong>字符串的数据较多，所以使用数字存储</strong></p>
<blockquote>
<p>可能不需要，之前看错题导致出现很多错误<br>但为了数字进位方便，还是用数字存储</p>
</blockquote>
<ol>
<li><strong>空字符串</strong>为 P态</li>
<li>数字无法存储前导0，且 0XXX 与 XXX 的结果不同</li>
<li>0XXX 可以一步到空字符串，也就是 N态，所以对其特判</li>
<li>其他数字按照组合游戏方法判断 PN 态。</li>
</ol>
<p>设 P 态为 $1$， N 态为 $0$。<br>因为总状态 $\le 10^8$打表计算后输出即可。</p>
<p><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(N<span class="number">+10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	<span class="type">int</span> _ = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(z &lt;= N)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> op = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(z/op &gt;= <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((z/op) % <span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(z/op) % <span class="number">10</span>;++i)	res |= a[z-op*i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	res |= a[z/(op*<span class="number">10</span>)];</span><br><span class="line">			op *= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		res |= <span class="number">0</span>;<span class="comment">// 不必要，代表0XXX</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;z/op;++i)	res |= a[z-op*i];<span class="comment">// 首位变成0 为 0XXX，而非XXX，所以去除掉</span></span><br><span class="line">		a[z] = !res;</span><br><span class="line">		z ++;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; _;</span><br><span class="line">	<span class="keyword">while</span>(_--)	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string st;</span><br><span class="line">	cin &gt;&gt; st;</span><br><span class="line">	<span class="keyword">if</span>(st[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)	cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; (a[<span class="built_in">stoi</span>(st)] ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dp打表"><a href="#dp打表" class="headerlink" title="dp打表"></a>dp打表</h4><p><strong>题面</strong><br>有一个01串。两个人在一起做游戏，ALICE先手，Bob后手，他们可以从以下两种操作中选一个：</p>
<ol>
<li>任选某个为0的位置将其变为1，代价为1。</li>
<li>若该01串目前不为回文串，且上一个操作不为操作2的情况下可以将整个01串翻转。</li>
</ol>
<p>代价少的人获胜，否则平局。<br><strong>sloution</strong><br>根据题意可知，字符的位置不重要，对称的关系才需要关注。</p>
<p>且如果对称位置为 <code>11</code>，那我就不需要再考虑了，因为无法再被修改。</p>
<p>所以可以可以记录每个状态为变为 (<code>00</code>,<code>11</code>,<code>mid</code>,<code>r_ed</code>)<br>分别是 <code>00</code>对的数目， <code>01</code>对的数目, 正中字符是 <code>1</code> 或 <code>0</code>，是否翻转过。</p>
<p>存储代价的最小值。因为值越小越可能赢</p>
<p>转移则看下列代码</p>
<p>对于每个状态，可以由至多四种可能转移而来<br><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	<span class="type">int</span> _ = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp); </span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;++k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&gt;=<span class="number">0</span>;--l)</span><br><span class="line">				&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>) dp[i][j][k][l] = <span class="built_in">min</span>(dp[i][j][k][l],<span class="number">1</span>-dp[i<span class="number">-1</span>][j<span class="number">+1</span>][k][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">0</span>) dp[i][j][k][l] = <span class="built_in">min</span>(dp[i][j][k][l],<span class="number">1</span>-dp[i][j<span class="number">-1</span>][k][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(k==<span class="number">1</span>) dp[i][j][k][l] = <span class="built_in">min</span>(dp[i][j][k][l],<span class="number">1</span>-dp[i][j][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(l==<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) dp[i][j][k][l] = <span class="built_in">min</span>(dp[i][j][k][l],-dp[i][j][k][<span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; _;</span><br><span class="line">	<span class="keyword">while</span>(_--)	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	string st;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; st;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">	&#123;</span><br><span class="line">		a[<span class="number">0</span>] += (st[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; st[n-i<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		a[<span class="number">1</span>] += st[i] != st[n-i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">2</span>] = (n&amp;<span class="number">1</span> &amp;&amp; st[n/<span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="type">int</span> z = dp[a[<span class="number">0</span>]][a[<span class="number">1</span>]][a[<span class="number">2</span>]][<span class="number">0</span>];</span><br><span class="line">	cout &lt;&lt; (z &lt; <span class="number">0</span> ? <span class="string">&quot;ALICE\n&quot;</span> : (z == <span class="number">0</span> ? <span class="string">&quot;DRAW\n&quot;</span> : <span class="string">&quot;BOB\n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Nim变体"><a href="#Nim变体" class="headerlink" title="Nim变体"></a>Nim变体</h4><p><strong>题面</strong><br>共有N堆石子，已知每堆中石子的数量，两个人轮流取石子，每次只能选择N堆石子中的一堆取一定数量的石子（最少取一个），取过子之后，还可以将该堆石子中剩余的石子随意选取几个放到其它的任意一堆或几堆上。等哪个人无法取子时就表示此人输掉了游戏。注意：一堆石子没有子之后，就不能再往此处放石子了。</p>
<p>假设每次都是小牛先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量，请判断出小牛能否获胜。<br><strong>sloution</strong></p>
<table>
<thead>
<tr>
<th>n</th>
<th>x</th>
<th>P-N</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Null</td>
<td>P</td>
</tr>
<tr>
<td>1</td>
<td>$x$</td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td>$x_1 &#x3D; x_2$</br>$x_1 &gt; x_2$</td>
<td>P</br>N</td>
</tr>
<tr>
<td>3</td>
<td>$x_1 \ge x_2 \ge x_3$</td>
<td>N</td>
</tr>
<tr>
<td>$\vdots$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$2\cdot k-1$</td>
<td>$x_1 \ge x_2 \ldots x_n$</td>
<td>N</td>
</tr>
<tr>
<td>$2\cdot$</td>
<td>$x_1 &#x3D; x_2,x_3 &#x3D; x_4$</br>other</td>
<td>P</br>N</td>
</tr>
</tbody></table>
<blockquote>
<p>详细推导就不写了</p>
</blockquote>
<p><strong>对于 $2\cdot k - 1$</strong><br>保证一次变成 $2\cdot k$ 且 $x_1 &#x3D; x_2 \ldots$<br>需要的代价是$x_2-x_3+x_4-x_5+ \ldots + x_{n-1} -x_{n}$<br>$\because -x_3+x_4 \le 0, -x_5+x_6 \le 0 \ldots$<br>且$x_2 \le x_1, -x_n \le 0$</p>
<p>$\therefore$ 代价 $\le x_1$<br><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span>(!n)	<span class="keyword">break</span>;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)	cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Win\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>,a.<span class="built_in">end</span>());</span><br><span class="line">		<span class="type">bool</span> op = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] != a[i<span class="number">+1</span>])	op = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; (op ? <span class="string">&quot;Lose\n&quot;</span> : <span class="string">&quot;Win\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="SG函数-2"><a href="#SG函数-2" class="headerlink" title="SG函数"></a>SG函数</h3><h4 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h4><p><strong>题面</strong><br>有一个 $n$ 个节点的有向无环图，编号为 $0$ 到 $n-1$。有若干轮游戏，每轮游戏给出 $m$ 个棋子在图上的节点位置（可能存在多个棋子在同一个节点上）。两个玩家轮流移动棋子，每次可以选择一个棋子将其移动到它的后继节点。无法移动任何棋子的一方判输。假设双方都采取最优策略，如果先手获胜输出 <code>&quot;WIN&quot;</code>，否则输出 <code>&quot;LOSE&quot;</code>。<br><strong>sloution</strong><br>经典SG<br>使用 <code>记忆化搜索</code> 求出各点sg函数后，对每个回答求点的 $\oplus$ 值即可。<br><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sg</span><span class="params">(N,<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sg</span><span class="params">(<span class="type">int</span> p)</span><span class="comment">// 记忆化搜索求sg</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// if(p == 0)	return 0;</span></span><br><span class="line">	<span class="keyword">if</span>(sg[p] != <span class="number">-1</span>)	<span class="keyword">return</span> sg[p];</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : a[p])	st.<span class="built_in">insert</span>(<span class="built_in">get_sg</span>(i));</span><br><span class="line">	<span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">count</span>(mex))	<span class="keyword">return</span> (sg[p] = mex);</span><br><span class="line">		mex ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k,x;	cin &gt;&gt; k;</span><br><span class="line">		<span class="comment">// if(k == 0)	sg[i] = 0;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)	<span class="built_in">get_sg</span>(i);</span><br><span class="line">	<span class="comment">// get_sg(0);</span></span><br><span class="line">	<span class="type">int</span> m,tmp;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; m &amp;&amp; m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(m --)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; tmp;</span><br><span class="line">			ans ^= sg[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; (ans ? <span class="string">&quot;WIN&quot;</span> : <span class="string">&quot;LOSE&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用规律优化sg速度（减少递归）"><a href="#使用规律优化sg速度（减少递归）" class="headerlink" title="使用规律优化sg速度（减少递归）"></a>使用规律优化sg速度（减少递归）</h4><p><strong>题面</strong><br>有 $n$ 个箱子，第 $i$ 个箱子的容量为 $s_i$，初始时装有 $c_i$ 颗石子。两名玩家轮流往箱子里放石子，每次放入的石子数必须满足：<br><strong>放入的数量不超过当前箱子内石子数的平方</strong>（例如，若某箱子当前有 $3$ 颗石子，则可放入 $1$ 到 $9$ 颗石子）。每次操作可以选择任意一个未满的箱子放入石子，直到某一方无法进行任何合法操作时判输。假设双方均采取最优策略，判断先手是否能获胜。若能获胜输出 <code>&quot;YES&quot;</code>，否则输出 <code>&quot;NO&quot;</code>。<br><strong>sloution</strong><br>到最后可以一步走到的点，可以直接得出其 g函数，而不需要再求 $mex$<br><strong>code</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">65</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">65</span>)</span>,<span class="title">g</span><span class="params">(N,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="comment">// vector&lt;vector&lt;int&gt;&gt; g(65,vector&lt;int&gt;(N,-1));</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sg</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p == s[k])	<span class="keyword">return</span> (g[p] = <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(g[p] != <span class="number">-1</span>)	<span class="keyword">return</span> g[p];</span><br><span class="line">	<span class="keyword">if</span>(p*(p<span class="number">+1</span>) &gt;= s[k])	<span class="keyword">return</span> s[k]-p;</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;p+i&lt;=s[k] &amp;&amp; i&lt;=p*p;++i)	st.<span class="built_in">insert</span>(<span class="built_in">get_sg</span>(k,p+i));</span><br><span class="line">	<span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">count</span>(mex))	<span class="keyword">return</span> (g[p] = mex);</span><br><span class="line">		mex ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; s[i] &gt;&gt; c[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=c[i];j&lt;=s[i];++j)	g[j] = <span class="number">-1</span>;</span><br><span class="line">		ans ^= <span class="built_in">get_sg</span>(i,c[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ans ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分裂游戏（sg打表找规律）"><a href="#分裂游戏（sg打表找规律）" class="headerlink" title="分裂游戏（sg打表找规律）"></a>分裂游戏（sg打表找规律）</h4><p><strong>题面</strong><br>Alice 和 Bob 厌倦了标准规则下的 Nim 游戏，因此他们修改了规则：允许玩家在每次操作时选择<strong>移除物品</strong>或<strong>将一堆分成两小堆</strong>。具体规则如下：</p>
<ol>
<li><strong>移除物品</strong>：从任意一堆中移除至少一个物品（规则与传统 Nim 相同）。</li>
<li><strong>分割堆</strong>：选择一堆，将其分成两堆较小的堆（堆的大小必须为正整数）。<br>游戏以正规则进行，即执行最后一次有效操作（移除最后一个物品或完成最后一次分割）的玩家获胜。<br><strong>sloution</strong><br><strong>$n$ 很大时，sg函数只能作为打表的辅助，不能直接求解。</strong><br>对于一组<strong>分裂游戏</strong>，虽然其可以分裂为多个子游戏，但是可以对其子游戏也求 Nim和，并作为更大单个游戏的子游戏，最后任可用sg函数求解。<br><strong>code</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sg</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g[p] != <span class="number">-1</span>)	<span class="keyword">return</span> g[p];</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;++i)	st.<span class="built_in">insert</span>(<span class="built_in">get_sg</span>(i)); <span class="comment">// 取出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;p;++i)	st.<span class="built_in">insert</span>(g[i]^g[p-i]);<span class="comment">// 分裂</span></span><br><span class="line">	<span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">count</span>(mex))	<span class="keyword">return</span> (g[p] = mex);</span><br><span class="line">		mex ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	<span class="type">int</span> _ = <span class="number">1</span>;</span><br><span class="line">	g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 调用sg打表</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;N;++i)	g[i] = -1;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;N;++i)	get_sg(i);</span></span><br><span class="line">	cin &gt;&gt; _;</span><br><span class="line">	<span class="keyword">while</span>(_--)	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,x,ans = <span class="number">0</span>;	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span>(n --)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span>(x%<span class="number">4</span> == <span class="number">0</span>)	x --;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">4</span> == <span class="number">3</span>)	x ++;</span><br><span class="line">		ans ^= x;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ans ? <span class="string">&quot;Alice\n&quot;</span> : <span class="string">&quot;Bob\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ACM/" rel="tag"># ACM</a>
              <a href="/tags/%E5%8D%9A%E5%BC%88/" rel="tag"># 博弈</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/17/%E9%9D%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="prev" title="非自动机字符串算法">
                  <i class="fa fa-angle-left"></i> 非自动机字符串算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/17/acam/" rel="next" title="AC自动机">
                  AC自动机 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">零云Y</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">15k</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
