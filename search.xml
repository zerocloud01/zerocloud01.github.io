<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC自动机</title>
    <url>/2025/09/17/acam/</url>
    <content><![CDATA[<h2 id="ac自动机">ac自动机</h2>
<h3 id="模板">模板</h3>
<p>trie树+fail（失配）指针
每个串保存trie树中最长相同前缀，这样失配的时候可以直接跳转匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,idx;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">26</span>],fail[N];</span><br><span class="line">bitset&lt;N&gt; ext;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ft[N];</span><br><span class="line"><span class="comment">// trie</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string &amp;st,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">    ext[p] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// acam</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_acam</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i)</span><br><span class="line">		<span class="keyword">if</span>(nxt[<span class="number">0</span>][i])	q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]), ft[<span class="number">0</span>].<span class="built_in">push_back</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][i]) nxt[p][i] = nxt[fail[p]][i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> ps = nxt[p][i];	q.<span class="built_in">push</span>(ps);</span><br><span class="line">                fail[ps] = nxt[fail[p]][i];</span><br><span class="line">				ft[fail[ps]].<span class="built_in">push_back</span>(ps);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query_acam</span><span class="params">(string &amp;st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,p=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="comment">// 因为trie树的节点被重构了，所以可以直接跑</span></span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">		<span class="comment">// do...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="套路">套路</h3>
<h4 id="反复删除添加模式串">反复删除添加模式串</h4>
<p>因为acam是离线算法，所以只能先把模式串全部加入建立trie图，然后再用数据结构维护。</p>
<h3 id="题目">题目</h3>
<h4 id="模式串出现总次数">模式串出现总次数</h4>
<ul>
<li><strong>多次</strong>查询一个字符串中模式串出现的<strong>总次数</strong>。</li>
<li>反复删除添加模式串</li>
</ul>
<p>离线维护。</p>
<p>因为模式串出现次数可以维护子树和得到，但这题有多次询问，每个询问只能使用
<span class="math inline"><em>O</em>(|<em>S</em>|)</span>
的时间，如果每次都遍历fail树会tle。</p>
<p>但是因为只需要求总次数，那么我们可以反向考虑，把单点修改区间查询改为区间修改单点查询，每次查询到一个模式串，那么在其fail树上的父亲节点都必然出现一次，这样也可以求到总次数。</p>
<blockquote>
<p>加上剖分可以用区间修改+区间查询维护</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,k,idx,tot;</span><br><span class="line"><span class="type">int</span> mp[N],dfn[N],sz[N];</span><br><span class="line"><span class="type">int</span> nxt[N][D],fail[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ft[N];</span><br><span class="line">bitset&lt;N&gt; vis;</span><br><span class="line"><span class="type">int</span> t[N],ti[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i&amp;-i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=tot;i+=<span class="built_in">lowbit</span>(i))	t[i] += z, ti[i] += l*z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r<span class="number">+1</span>;i&lt;=tot;i+=<span class="built_in">lowbit</span>(i))	t[i] -= z, ti[i] -= (r<span class="number">+1</span>)*z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))	res -= (l)*t[i] - ti[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))		res += (r<span class="number">+1</span>)*t[i] - ti[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string &amp;st,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	mp[id] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[p] = ++ tot;</span><br><span class="line">	sz[p] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ft[p])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">		sz[p] += sz[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_acam</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(nxt[<span class="number">0</span>][i])</span><br><span class="line">		&#123;</span><br><span class="line">			ft[<span class="number">0</span>].<span class="built_in">push_back</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">			q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][i])	nxt[p][i] = nxt[fail[p]][i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> ps = nxt[p][i];	q.<span class="built_in">push</span>(ps);</span><br><span class="line">				fail[ps] = nxt[fail[p]][i];</span><br><span class="line">				ft[fail[ps]].<span class="built_in">push_back</span>(ps);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_acam</span><span class="params">(string &amp;st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,p=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">		res += <span class="built_in">query</span>(dfn[p],dfn[p]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">a</span><span class="params">(k<span class="number">+1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">insert</span>(a[i],i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build_acam</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">put</span>(dfn[mp[i]],dfn[mp[i]]+sz[mp[i]]<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">		vis[i] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(n --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> c;	cin &gt;&gt; c;</span><br><span class="line">		<span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t;	cin &gt;&gt; t;</span><br><span class="line">			<span class="keyword">if</span>(!vis[t] &amp;&amp; c == <span class="string">&#x27;+&#x27;</span>)		<span class="built_in">put</span>(dfn[mp[t]],dfn[mp[t]]+sz[mp[t]]<span class="number">-1</span>,<span class="number">1</span>), vis[t] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(vis[t] &amp;&amp; c == <span class="string">&#x27;-&#x27;</span>)	<span class="built_in">put</span>(dfn[mp[t]],dfn[mp[t]]+sz[mp[t]]<span class="number">-1</span>,<span class="number">-1</span>), vis[t] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			string s;	cin &gt;&gt; s;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query_acam</span>(s) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子串删除问题">子串删除问题</h4>
<p>给定一个字符串 <span class="math inline"><em>S</em></span>
和一个字典，反复删除 <span class="math inline"><em>S</em></span>
在字典出现的第一个模式串</p>
<p>和前面那道kmp一样，只不过这题需要删除所有模式串的结果。</p>
<p>解法和那题差不多，只不过需要存储匹配的自动机节点，而非border串长度（其实本质是相同的）
这里没有用erase，而是用了栈，刚好两道题可以互相对应 <a
href="./KMP.md/#反复删除子串">反复删除子串</a> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s0;</span><br><span class="line"><span class="type">int</span> n,idx,tmp[N];</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">26</span>],fail[N];</span><br><span class="line"><span class="type">int</span> ext[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string &amp;st,<span class="type">int</span> L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	ext[p] = L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_acam</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][i])	nxt[p][i] = nxt[fail[p]][i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> ps = nxt[p][i];</span><br><span class="line">				fail[ps] = fail[p];</span><br><span class="line">				<span class="keyword">while</span>(fail[ps] &amp;&amp; !nxt[fail[ps]][i])	fail[ps] = fail[fail[ps]];</span><br><span class="line">				<span class="keyword">if</span>(p &amp;&amp; nxt[fail[ps]][i])	fail[ps] = nxt[fail[ps]][i];</span><br><span class="line">				q.<span class="built_in">push</span>(ps);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; s0 &gt;&gt; n;</span><br><span class="line">	string st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; st;</span><br><span class="line">		<span class="built_in">insert</span>(st,st.<span class="built_in">size</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;pair&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">	<span class="built_in">build_acam</span>();</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s<span class="number">0.</span><span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = s0[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">		</span><br><span class="line">		ans.<span class="built_in">push_back</span>(&#123;s0[i],<span class="number">0</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(ext[p])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=ext[p];j&gt;<span class="number">0</span>;--j)	ans.<span class="built_in">pop_back</span>();</span><br><span class="line">			p = (ans.<span class="built_in">size</span>() ? (ans.<span class="built_in">back</span>()).Y : <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans.<span class="built_in">size</span>())	ans.<span class="built_in">back</span>().Y = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ans)	cout &lt;&lt; i.X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ####
模式串出现次数 统计模式串在字典中的出现次数</p>
<p>求fail树上该节点的子树大小，其实也和kmp求出现次数一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,idx;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">26</span>],fail[N];</span><br><span class="line"><span class="type">int</span> cnt[N],mp[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ft[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string &amp;st,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">		cnt[p] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	mp[id] = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_acam</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;	q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> lp = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[lp][i])	nxt[lp][i] = nxt[fail[lp]][i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> p = nxt[lp][i];</span><br><span class="line">				fail[p] = fail[lp];</span><br><span class="line">				<span class="keyword">while</span>(fail[p] &amp;&amp; !nxt[fail[p]][i])	fail[p] = fail[fail[p]];</span><br><span class="line">				<span class="keyword">if</span>(lp &amp;&amp; nxt[fail[p]][i])	fail[p] = nxt[fail[p]][i];</span><br><span class="line">				ft[fail[p]].<span class="built_in">push_back</span>(p);</span><br><span class="line">				q.<span class="built_in">push</span>(p);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ft[p])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">		cnt[p] += cnt[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	string st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; st;</span><br><span class="line">		<span class="built_in">insert</span>(st,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build_acam</span>();</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)	cout &lt;&lt; cnt[mp[i]] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="acam-dp">acam dp</h4>
<p>acam_dp 好像相对比较套路，都是 <span
class="math inline"><em>d</em><em>p</em><sub><em>i</em>, <em>j</em></sub></span>，表示在前
<span class="math inline"><em>i</em></span> 个状态，到达trie图第 <span
class="math inline"><em>j</em></span> 个节点的状态。<span
class="math inline"><em>d</em><em>p</em><sub><em>i</em>, <em>n</em><em>x</em><em>t</em><sub><em>j</em></sub></sub> ← <em>d</em><em>p</em><sub><em>i</em> − 1, <em>j</em></sub></span>。</p>
<h5 id="随机串最多出现多少模式串">随机串最多出现多少模式串</h5>
<p>P3041 [USACO12JAN] Video Game G Bessie
在玩一款游戏，该游戏只有三个技能键
<code>A</code>，<code>B</code>，<code>C</code> 可用，但这些键可用形成
<span class="math inline"><em>n</em></span> 种特定的组合技。第 <span
class="math inline"><em>i</em></span> 个组合技用一个字符串 <span
class="math inline"><em>s</em><sub><em>i</em></sub></span> 表示。</p>
<p>Bessie 会输入一个长度为 <span class="math inline"><em>k</em></span>
的字符串 <span class="math inline"><em>t</em></span>，而一个组合技每在
<span class="math inline"><em>t</em></span> 中出现一次，Bessie
就会获得一分。<span
class="math inline"><em>s</em><sub><em>i</em></sub></span> 在 <span
class="math inline"><em>t</em></span> 中出现一次指的是 <span
class="math inline"><em>s</em><sub><em>i</em></sub></span> 是 <span
class="math inline"><em>t</em></span> 从某个位置起的连续子串。如果 <span
class="math inline"><em>s</em><sub><em>i</em></sub></span> 从 <span
class="math inline"><em>t</em></span> 的多个位置起都是连续子串，那么算作
<span class="math inline"><em>s</em><sub><em>i</em></sub></span>
出现了多次。</p>
<p>若 Bessie 输入了恰好 <span class="math inline"><em>k</em></span>
个字符，则她最多能获得多少分？</p>
<p><strong>solution</strong> <code>dp[i][j]</code> 表示长度为 <span
class="math inline"><em>i</em></span> 的以 acam节点<span
class="math inline"><em>j</em></span> 为结尾字符串最大 <span
class="math inline"><em>d</em><em>p</em></span> 值</p>
<p>那么dp每次就可以从acam树上的父节点转移到子节点 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,idx;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">3</span>],fail[N],val[N];</span><br><span class="line"><span class="type">int</span> dp[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string &amp;st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	val[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_acam</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(nxt[<span class="number">0</span>][i])	q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> lp = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[lp][i])	nxt[lp][i] = nxt[fail[lp]][i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> p = nxt[lp][i];</span><br><span class="line">				fail[p] = nxt[fail[lp]][i];</span><br><span class="line">				q.<span class="built_in">push</span>(p);</span><br><span class="line">				val[p] += val[fail[p]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		string st;	cin &gt;&gt; st;</span><br><span class="line">		<span class="built_in">insert</span>(st);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build_acam</span>();</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0xaf</span>,<span class="keyword">sizeof</span> dp); <span class="comment">// -inf</span></span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=idx;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;++k)	dp[i][nxt[j][k]] = <span class="built_in">max</span>(dp[i][nxt[j][k]],dp[i<span class="number">-1</span>][j]+val[nxt[j][k]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=idx;++i)	ans = <span class="built_in">max</span>(ans,dp[m][i]);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="随机串存在模式串的串总数">随机串存在模式串的串总数</h5>
<p>P4052 [JSOI2007] 文本生成器 JSOI 交给队员 ZYX
一个任务，编制一个称之为“文本生成器”的电脑软件：该软件的使用者是一些低幼人群，他们现在使用的是
GW 文本生成器 v6 版。</p>
<p>该软件可以随机生成一些文章——总是生成一篇长度固定且完全随机的文章。
也就是说，生成的文章中每个字符都是完全随机的。如果一篇文章中至少包含使用者们了解的一个单词，那么我们说这篇文章是可读的（我们称文章
<span class="math inline"><em>s</em></span> 包含单词 <span
class="math inline"><em>t</em></span>，当且仅当单词 <span
class="math inline"><em>t</em></span> 是文章 <span
class="math inline"><em>s</em></span>
的子串）。但是，即使按照这样的标准，使用者现在使用的 GW 文本生成器 v6
版所生成的文章也是几乎完全不可读的。ZYX 需要指出 GW 文本生成器 v6
生成的所有文本中，可读文本的数量，以便能够成功获得 v7
更新版。你能帮助他吗？</p>
<p>和上一题不同，求的是子串存在模式串的串总数 <strong>solution</strong>
求存在不方便，所以求不存在 <code>dp[i][j]</code> 表示长度为 <span
class="math inline"><em>i</em></span> 的以 acam节点<span
class="math inline"><em>j</em></span> 为结尾的字符串不存在字典串总数</p>
<p>最后再 <span
class="math inline"><em>s</em><em>u</em><em>m</em> − <em>d</em><em>p</em></span>
即可 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,idx;</span><br><span class="line"><span class="type">int</span> nxt[N][D],fail[N];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][N];</span><br><span class="line">bitset&lt;N&gt; ext;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string &amp;st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	ext[p] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_acam</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">		<span class="keyword">if</span>(nxt[<span class="number">0</span>][i])	q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][i])	nxt[p][i] = nxt[fail[p]][i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> ps = nxt[p][i];	q.<span class="built_in">push</span>(ps);</span><br><span class="line">				fail[ps] = nxt[fail[p]][i];</span><br><span class="line">				ext[ps] = ext[fail[ps]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		string st;	cin &gt;&gt; st;</span><br><span class="line">		<span class="built_in">insert</span>(st);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build_acam</span>();</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=idx;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;D;++k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!ext[nxt[j][k]])	dp[i][nxt[j][k]] = (dp[i][nxt[j][k]]+dp[i<span class="number">-1</span>][j])%M;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)	ans = (ans*<span class="number">26</span>)%M;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=idx;++i)	ans = (ans-dp[m][i]+M)%M;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="随机串存在所有模式串的串总数">随机串存在所有模式串的串总数</h5>
<p>这题只有 <span class="math inline"><em>n</em> ≤ 10</span>
个串，用状压表示即可。 abc419_f <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,L,idx;</span><br><span class="line"><span class="type">int</span> nxt[N][D],fail[N];</span><br><span class="line"><span class="type">int</span> ext[N];</span><br><span class="line"><span class="type">int</span> dp[N][N][N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ft[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string &amp;st,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	ext[p] = <span class="number">1</span>&lt;&lt;id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ft[p])</span><br><span class="line">	&#123;</span><br><span class="line">		ext[i] |= ext[p];</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_acam</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(nxt[<span class="number">0</span>][i])</span><br><span class="line">		&#123;</span><br><span class="line">			ft[<span class="number">0</span>].<span class="built_in">push_back</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">			q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][i])	nxt[p][i] = nxt[fail[p]][i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> ps = nxt[p][i];	q.<span class="built_in">push</span>(ps);</span><br><span class="line">				fail[ps] = nxt[fail[p]][i];</span><br><span class="line">				ft[fail[ps]].<span class="built_in">push_back</span>(ps);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; L;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		string st;	cin &gt;&gt; st;</span><br><span class="line">		<span class="built_in">insert</span>(st,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build_acam</span>();</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=idx;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;n);++k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;D;++x)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> p = nxt[j][x], y = k|(ext[p]);</span><br><span class="line">					dp[i][p][y] = (dp[i][p][y] + dp[i<span class="number">-1</span>][j][k])%P;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=idx;++i)	ans = (ans + dp[L][i][(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>])%P;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="模式串互相匹配">模式串互相匹配</h4>
<p>求模式串在模式串的出现次数</p>
<p>等同于求有多少个属于Y的节点的fail指针直接或间接指向X的结束位置</p>
<p>那么我们对fail求dfn，然后跑<strong>trie树</strong>，离线询问并用树状数组维护出现次数
&gt; 因为是模式串在模式串，所以只能跑原始trie树 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> m,idx,tot;</span><br><span class="line"><span class="type">int</span> dfn[N],sz[N],t[N];</span><br><span class="line"><span class="type">int</span> nxt[N][D],trie[N][D],fail[N],ans[N],mp[N],fa[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ft[N];</span><br><span class="line">vector&lt;PII&gt; eq[N];</span><br><span class="line">string st,s0;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=tot;i+=i&amp;-i)	t[i] += z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r;i&gt;=<span class="number">1</span>;i-=i&amp;-i)	res += t[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i-=i&amp;-i)	res -= t[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[p] = ++ tot;</span><br><span class="line">	sz[p] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : ft[p])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(i);</span><br><span class="line">		sz[p] += sz[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_acam</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(nxt[<span class="number">0</span>][i])</span><br><span class="line">		&#123;</span><br><span class="line">			q.<span class="built_in">push</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">			ft[<span class="number">0</span>].<span class="built_in">push_back</span>(nxt[<span class="number">0</span>][i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;D;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][i])		nxt[p][i] = nxt[fail[p]][i];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> ps = nxt[p][i];	q.<span class="built_in">push</span>(ps);</span><br><span class="line">				fail[ps] = nxt[fail[p]][i];</span><br><span class="line">				ft[fail[ps]].<span class="built_in">push_back</span>(ps);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_trie</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">put</span>(dfn[p],<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,id] : eq[p])	ans[id] = <span class="built_in">query</span>(dfn[x],dfn[x]+sz[x]<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(trie[p][i])	<span class="built_in">dfs_trie</span>(trie[p][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">put</span>(dfn[p],<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	string s0;	cin &gt;&gt; s0;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : s0)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(st.<span class="built_in">size</span>())	st.<span class="built_in">erase</span>(st.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">			p = fa[p];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j : st)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> c = j-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">				<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">				trie[p][c] = nxt[p][c];</span><br><span class="line">				fa[nxt[p][c]] = p;</span><br><span class="line">				p = nxt[p][c];</span><br><span class="line">			&#125;</span><br><span class="line">			mp[++ cnt] = p;</span><br><span class="line">			st.<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>	st += i;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="built_in">build_acam</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y;	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		eq[mp[y]].<span class="built_in">push_back</span>(&#123;mp[x],i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs_trie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)	cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>string</category>
        <category>自动机</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>string</tag>
        <tag>自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路</title>
    <url>/2025/09/17/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="最短路">最短路</h2>
<p><strong>只需要把边权全部取反，就可以求得最长路，且可以判正环</strong></p>
<h3 id="单源最短路-dijkstra">单源最短路 dijkstra</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> st,<span class="type">int</span> d[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)	d[i] = M;<span class="comment">// 初始化</span></span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	d[st] = <span class="number">0</span>;<span class="comment">// 起始位置</span></span><br><span class="line">	bitset&lt;N&gt; vis;<span class="comment">// 去重，防止重复访问降速</span></span><br><span class="line">	pq.<span class="built_in">push</span>(&#123;st,d[st]&#125;);</span><br><span class="line">	<span class="keyword">while</span>(pq.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = pq.<span class="built_in">top</span>().y;	pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[x])	<span class="keyword">continue</span>;</span><br><span class="line">		vis[x] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[y,v] : a[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[y] &gt; d[x] + v)</span><br><span class="line">			&#123;</span><br><span class="line">				d[y] = d[x] + v;</span><br><span class="line">				pq.<span class="built_in">push</span>(&#123;y,d[y]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="负权单源最短路">负权单源最短路</h3>
<h4 id="bellmanford">Bellman–Ford</h4>
<p><span class="math inline"><em>O</em>(<em>n</em><em>m</em>)</span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bellman_ford</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用于判负环，在 第 n 次任可松弛，证明有负环</span></span><br><span class="line">	<span class="type">bool</span> op = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">// n 次枚举</span></span><br><span class="line">	&#123;</span><br><span class="line">		op = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=n;++x)<span class="comment">// 共 m 条边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[y,v] : a[x])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(d[y] &gt; d[x] + v)</span><br><span class="line">				&#123;</span><br><span class="line">					d[y] = d[x] + v;</span><br><span class="line">					op = <span class="literal">true</span>;					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### SPFA <span
class="math inline"><em>O</em>() ≪ <em>O</em>(<em>n</em><em>m</em>)</span>
但<strong>最坏 <span
class="math inline"><em>O</em>(<em>n</em><em>m</em>)</span>，且很容易这么卡</strong>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> st,<span class="type">int</span> d[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 保证每个点只有松弛过才能用来松弛</span></span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	bitset&lt;N&gt; inq;</span><br><span class="line">	q.<span class="built_in">push</span>(st);</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = q.<span class="built_in">front</span>();	q.<span class="built_in">pop</span>();	inq[x] = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[y,v] : a[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(d[y] &gt; d[x] + v)</span><br><span class="line">			&#123;</span><br><span class="line">                <span class="comment">// 一条边最多松弛 $n-1$ 次，否则负环</span></span><br><span class="line">				<span class="keyword">if</span>(++ cnt[y] &gt;= n)	<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 负环</span></span><br><span class="line">				d[y] = d[x] + v;</span><br><span class="line">				<span class="keyword">if</span>(!inq[y])	q.<span class="built_in">push</span>(y), inq[y] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多源最短路">多源最短路</h3>
<h4 id="floyd">floyd</h4>
<p><span class="math inline"><em>O</em>(<em>n</em><sup>3</sup>)</span>
<strong>使用邻接矩阵</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)	d[i][j] = (i == j ? <span class="number">0</span> : M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">			&#123;</span><br><span class="line">				d[i][j] = <span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="多次-dijkstra">多次 dijkstra</h4>
<p>对一个点求多次 <code>dijkstra</code> 也可以</p>
<h3 id="负权单源最短路-johnson">负权单源最短路 Johnson</h3>
<p><strong>spfa判负环需要 <span class="math inline"><em>n</em></span>
次，因为加上虚拟零点后有 <span class="math inline"><em>n</em> + 1</span>
个点</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> d[N][N], h[N];<span class="comment">// 最短路，势能</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">johnson</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 构造虚拟零点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)	a[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="comment">// spfa 求势能 h</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)	h[i] = M;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">spfa</span>(<span class="number">0</span>,h))	<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 判负环</span></span><br><span class="line">	<span class="comment">// 用势能改造边为非负权</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[j,v] : a[i])	v += h[i] - h[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// n 次单源最短路</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)	<span class="built_in">dijkstra</span>(i,d[i]);</span><br><span class="line">	<span class="comment">// 复原</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)	d[i][j] -= h[i] - h[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>图论</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2025/09/17/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="树状数组">树状数组</h2>
<h3 id="单点修改维护区间和">单点修改维护区间和</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], t[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> z&amp;-z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> z)</span><span class="comment">// 单点修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))  t[i] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">// 区间查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))	res1 += t[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))		res2 += t[i];</span><br><span class="line">    <span class="keyword">return</span> res2-res1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间修改维护区间和">区间修改维护区间和</h3>
<p>维护差分 <em>其实没啥用了, 我会线段树</em> <span
class="math inline">$\sum_{i=1}^n a_i = \sum_{i=1}^n
\overbrace{(n+1)d_i}^{t_1} -
\sum_{i=1}^n\overbrace{id_i}^{t_2}$</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> t[N],ti[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> i&amp;-i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))	t[i] += z, ti[i] += l*z;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r<span class="number">+1</span>;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))	t[i] -= z, ti[i] -= (r<span class="number">+1</span>)*z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))	res -= (l)*t[i] - ti[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=r;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))		res += (r<span class="number">+1</span>)*t[i] - ti[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="维护逆序对">维护逆序对</h3>
<p>按出现顺序依次加入树状数组，每次可得当前小于（大于）等于自己的数目（也就是前面比自己小/大的数目），计算即可得逆序对。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(N)</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; dis,</span>;<span class="comment">// dis离散化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 寻找离散化下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">lower_bound</span>(dis.<span class="built_in">begin</span>(),dis.<span class="built_in">end</span>(),x)-dis.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">	<span class="comment">// 下标存入树状数组，保证下标从1开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> z&amp;-z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))	t[i] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=p;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))	res += t[i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)	cin &gt;&gt; a[i];</span><br><span class="line">	dis = a;</span><br><span class="line">	<span class="built_in">sort</span>(dis.<span class="built_in">begin</span>(),dis.<span class="built_in">end</span>());</span><br><span class="line">	dis.<span class="built_in">erase</span>(<span class="built_in">unique</span>(dis.<span class="built_in">begin</span>(),dis.<span class="built_in">end</span>()),dis.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		ans += i-<span class="built_in">query</span>(<span class="built_in">get</span>(a[i]));</span><br><span class="line">		<span class="built_in">update</span>(<span class="built_in">get</span>(a[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>树状数组</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈</title>
    <url>/2025/09/17/%E5%8D%9A%E5%BC%88%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><strong>概念：</strong>
博弈论是研究具有斗争或竞争性性质现象的数学理论和方法。</p>
<p>假设玩家的集合是 <span class="math inline"><em>N</em></span>，第
<span class="math inline"><em>i</em></span> 个玩家的策略集合是 <span
class="math inline">∑<sup><em>i</em></sup></span>，游戏的结果集合为
<span
class="math inline"><em>Γ</em></span>，关于每个玩家使用不同的策略，游戏产生对应的结果，及
<span
class="math display"><em>π</em> : ∏<sub><em>i</em> ∈ <em>n</em></sub>(∑<sup><em>i</em></sup>) → <em>Γ</em></span></p>
<h2 id="组合游戏">组合游戏</h2>
<blockquote>
<p>博弈的子集</p>
</blockquote>
<h3 id="特征">特征</h3>
<ul>
<li>两个玩家</li>
<li>一个状态集合</li>
<li>游戏规则是指明玩家在一个状态可以转移到其他状态</li>
<li>玩家轮流进行移动</li>
<li>如果当前处于某个状态，玩家根据规则无法移动，游戏结束。</li>
<li>（<strong>大部分时候</strong>）无论玩家如何选择，游戏都会在有限步内结束。</li>
</ul>
<p><strong>可以将组合游戏理解为有向无环图</strong></p>
<h2 id="bash游戏">Bash游戏</h2>
<p>在 <span class="math inline"><em>N</em></span> 堆石子中轮流取 <span
class="math inline">[1, <em>M</em>]</span> 个，谁不能取输。</p>
<blockquote>
<p>结论：当 <span
class="math inline"><em>N</em> = <em>k</em> ⋅ (<em>M</em> + 1)</span>
A输，否则A赢</p>
</blockquote>
<h3 id="状态集合">状态集合：</h3>
<p><span
class="math inline"><em>S</em> = 0, 1, 2, …, <em>N</em></span>，<span
class="math inline"><em>i</em>→</span> 当前剩 <span
class="math inline"><em>i</em></span> 个石子 ### PN态
<strong>P状态：</strong> - privious position -
走到该状态的玩家胜利（离开失败） - <strong>不能</strong>走到
<strong>P状态</strong> 的为P状态</p>
<p><strong>N状态：</strong> - nest position - 离开该状态的玩家胜利 -
<strong>可以</strong>走到 <strong>P状态</strong> 的为 N状态</p>
<p><u>根据结束状态（无法走到其他状态位置）为 P 或 N来反向转移</u></p>
<h3 id="普适解题方法">（普适）解题方法</h3>
<ul>
<li>打表，找规律（DP，搜索）</li>
<li><code>guess</code>，猜结论</li>
<li>证明（理由PN态）</li>
</ul>
<h2 id="nim游戏">Nim游戏</h2>
<p>有 <span class="math inline"><em>N</em></span> 堆石子，第 <span
class="math inline"><em>i</em></span> 堆有 <span
class="math inline"><em>a</em><sub><em>i</em></sub></span>
个。轮流取，每次取<strong>一堆</strong>中的<strong>至少一个</strong>，不能取的失败。
### P-N分析 &gt; 默认 <span
class="math inline"><em>x</em><sub>1</sub> ≥ <em>x</em><sub>2</sub> ≥ <em>x</em><sub>3</sub> ≥ ⋯ ≥ <em>x</em><sub><em>n</em></sub></span></p>
<table>
<thead>
<tr>
<th>n</th>
<th style="text-align: center;">x</th>
<th>P-N</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td style="text-align: center;"></td>
<td>P</td>
</tr>
<tr>
<td>1</td>
<td style="text-align: center;"><span
class="math inline"><em>x</em></span></td>
<td>N</td>
</tr>
<tr>
<td>2</td>
<td style="text-align: center;"><span
class="math inline"><em>x</em><sub>1</sub> = <em>x</em><sub>2</sub></span></br><span
class="math inline"><em>x</em><sub>1</sub> ≠ <em>x</em><sub>2</sub></span></td>
<td>P</br>N</td>
</tr>
<tr>
<td>3</td>
<td style="text-align: center;"><span class="math inline">…</span></td>
<td><span class="math inline">…</span></td>
</tr>
</tbody>
</table>
<h3 id="结论">结论</h3>
<ul>
<li><span
class="math inline"><em>x</em><sub>1</sub> ⊕ <em>x</em><sub>2</sub> ⊕ <em>x</em><sub>3</sub> ⊕ … ⊕ <em>x</em><sub><em>n</em></sub> = 0</span>
<strong>P态</strong></li>
<li><span
class="math inline"><em>x</em><sub>1</sub> ⊕ <em>x</em><sub>2</sub> ⊕ <em>x</em><sub>3</sub> ⊕ … ⊕ <em>x</em><sub><em>n</em></sub> &gt; 0</span>
<strong>N态</strong></li>
</ul>
<p><strong>推导</strong> 对于 <span
class="math inline"><em>x</em><sub>1</sub> ⊕ <em>x</em><sub>2</sub> ⊕ <em>x</em><sub>3</sub> ⊕ … ⊕ <em>x</em><sub><em>n</em></sub> = 0</span>，一次操作后不可能保持
<span class="math inline"> = 0</span>，必然变为 <span
class="math inline"> &gt; 0</span>。 而对于 <span
class="math inline"><em>x</em><sub>1</sub> ⊕ <em>x</em><sub>2</sub> ⊕ <em>x</em><sub>3</sub> ⊕ … ⊕ <em>x</em><sub><em>n</em></sub> &gt; 0</span>，只需让存有最高位
<span class="math inline">1</span>
的数，减去其他1组成的数，异或和就将变为 <span
class="math inline">0</span></p>
<h2 id="sg函数">SG函数</h2>
<h3 id="图游戏">图游戏</h3>
<p><strong>图游戏是一种组合游戏的抽象描述</strong> 给定一个有向图 <span
class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>，<span
class="math inline"><em>V</em></span> 是非空点集，<span
class="math inline"><em>E</em></span> 是有向边集。两个人在图 <span
class="math inline"><em>G</em></span> 上进行游戏。从起始节点 <span
class="math inline"><em>x</em><sub>0</sub></span>
出发，轮流移动。每一轮当前玩家可以从当前节点 <span
class="math inline"><em>x</em></span> 按照邮箱边集移动到下一个节点，把
<span class="math inline"><em>x</em></span> 可以一步移动到的节点集合记为
<span class="math inline"><em>F</em>(<em>x</em>)</span>。如果 <span
class="math inline"><em>F</em>(<em>x</em>)</span> 为空，则 <span
class="math inline"><em>x</em></span>
为终止结点，此时玩家不能移动，游戏结束。 &gt;
只讨论无环，且在有限次内终止的情况（否则无意义）</p>
<h3 id="sg函数-1">SG函数</h3>
<p>定义有向无环图 <span
class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>
的SG函数是一个结点集 <span class="math inline"><em>V</em></span>
到非负整数 <span class="math inline"><em>Z</em> ≥ 0</span> 的映射。</p>
<p><span
class="math inline"><em>g</em> : <em>V</em> → <em>Z</em><sub> ≥ 0</sub></span>，满足<span
class="math inline">  <em>g</em>(<em>x</em>) = <em>m</em><em>e</em><em>x</em>{<em>g</em>(<em>x</em>)|<em>y</em> ∈ <em>F</em>(<em>x</em>)}</span></p>
<h3 id="sg函数与pn关系">SG函数与PN关系</h3>
<ul>
<li><span class="math inline"><em>x</em></span> 为P态当且仅当 <span
class="math inline"><em>g</em>(<em>x</em>) = 0</span></li>
<li><span class="math inline"><em>x</em></span> 为N态当且仅当 <span
class="math inline"><em>g</em>(<em>x</em>) &gt; 0</span></li>
</ul>
<h2 id="组合游戏的和">组合游戏的和</h2>
<p>给定多个组合游戏，可以用如下方式把他们进行组合。每个游戏都有一个初始状态，每次当前玩家可以选择一个游戏，并按照该游戏的规则移动一次，如果轮到当前玩家时，所有游戏都不能移动，则玩家输（正常规则）。称这个新的组合游戏为这些</p>
<blockquote>
<p>nim游戏就可以看成若干个游戏的和</p>
</blockquote>
<h3 id="图游戏的和">图游戏的和</h3>
<p>假设给定 <span class="math inline"><em>n</em></span> 个邮箱无换图
<span
class="math inline"><em>G</em><sub><em>i</em></sub>(<em>V</em><sub><em>i</em></sub>, <em>E</em><sub><em>i</em></sub>)</span>，则它们的图游戏的和
<span
class="math inline"><em>G</em>(<em>V</em>, <em>E</em>)</span>，满足 -
<span
class="math inline"><em>V</em> = <em>V</em><sub>1</sub> × <em>V</em><sub>2</sub> × <em>V</em><sub>3</sub> × … × <em>V</em><sub><em>n</em></sub></span>
&gt;笛卡尔乘积是指在数学中，两个集合 <span
class="math inline"><em>X</em></span> 和 <span
class="math inline"><em>Y</em></span> 的笛卡尔积（Cartesian
product），又称直积，表示为 <span
class="math inline"><em>X</em> × <em>Y</em></span>，第一个对象是 <span
class="math inline"><em>X</em></span> 的成员而第二个对象是 <span
class="math inline"><em>Y</em></span> 的所有可能有序对的其中一个成员 -
结点 <span
class="math inline"><em>x</em> = (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x</em><sub><em>n</em></sub>)</span>
一步能到 <span
class="math inline"><em>F</em>(<em>x</em>) = <em>U</em><sub><em>i</em> = 1</sub><sup><em>n</em></sup>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>y</em><sub><em>i</em></sub>, …<em>x</em><sub><em>n</em></sub>)|<em>y</em><sub><em>i</em></sub> ∈ <em>F</em><sub><em>i</em></sub>(<em>x</em><sub><em>i</em></sub>)</span>
&gt; <span class="math inline"><em>x</em><sub><em>i</em></sub></span>
走向 <span
class="math inline"><em>y</em><sub><em>i</em></sub></span>。</p>
<p>记 <span class="math inline"><em>G</em></span> 为 <span
class="math inline"><em>G</em><sub>1</sub> + <em>G</em><sub>2</sub> + … + <em>G</em><sub><em>n</em></sub></span>。</p>
<h3 id="sg定理">SG定理</h3>
<p>假设有 <span class="math inline"><em>n</em></span> 个组合游戏 <span
class="math inline"><em>G</em><sub>1</sub>, <em>G</em><sub>2</sub>, …, <em>G</em><sub><em>n</em></sub></span>，记
<span class="math inline"><em>g</em><sub><em>i</em></sub></span> 为第
<span class="math inline"><em>i</em>(1 ≤ <em>i</em> ≤ <em>n</em>)</span>
个组合游戏的SG函数，则它们的和 <span
class="math inline"><em>G</em> = <em>G</em><sub>1</sub> + <em>G</em><sub>2</sub> + … + <em>G</em><sub><em>N</em></sub></span>的SG函数。
<span
class="math inline"><em>g</em>(<em>x</em>) = <em>g</em>((<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …)) = <em>g</em>(<em>x</em><sub>1</sub>) ⊕ <em>g</em>(<em>x</em><sub>2</sub>) ⊕ …<em>g</em><sub><em>n</em></sub>(<em>x</em><sub><em>n</em></sub>)</span></p>
<h3 id="推论">推论</h3>
<p>假设 <span
class="math inline"><em>G</em> = <em>G</em><sub>1</sub> + <em>G</em><sub>2</sub> + … + <em>G</em><sub><em>n</em></sub></span>
- <span
class="math inline"><em>x</em> = (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x</em><sub><em>n</em></sub>)</span>
是 P 态当且仅当 <span
class="math inline"><em>g</em>(<em>x</em><sub>1</sub>) ⊕ <em>g</em>(<em>x</em><sub>2</sub>) ⊕ …<em>g</em><sub><em>n</em></sub>(<em>x</em><sub><em>n</em></sub>) = 0</span>
- <span
class="math inline"><em>x</em> = (<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x</em><sub><em>n</em></sub>)</span>
是 N 态当且仅当 <span
class="math inline"><em>g</em>(<em>x</em><sub>1</sub>) ⊕ <em>g</em>(<em>x</em><sub>2</sub>) ⊕ …<em>g</em><sub><em>n</em></sub>(<em>x</em><sub><em>n</em></sub>) &gt; 0</span></p>
<p><strong>sg的相较比较PN态，优点在于：</strong><b style="color: red">
可以求多个游戏的组合 </b></p>
<h3 id="code">code</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sg</span><span class="params">(<span class="type">int</span> p)</span><span class="comment">// 记忆化搜索求sg</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// if(p == 0)	return 0;</span></span><br><span class="line">	<span class="keyword">if</span>(sg[p] != <span class="number">-1</span>)	<span class="keyword">return</span> sg[p];</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : a[p])	st.<span class="built_in">insert</span>(<span class="built_in">get_sg</span>(i));</span><br><span class="line">	<span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">count</span>(mex))	<span class="keyword">return</span> (sg[p] = mex);</span><br><span class="line">		mex ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题目">题目</h2>
<h3 id="组合游戏转移">组合游戏转移</h3>
<h4 id="递归转移求最值">递归转移求最值</h4>
<p><strong>题面</strong> 设计师们想出了一个名为“Rake It
In”的新简单游戏。两个玩家，Alice和Bob，最初选择一个整数 <span
class="math inline"><em>k</em></span> 并初始化一个分数指示器。创建一个
<span class="math inline">4 × 4</span> 的棋盘，棋盘上有 <span
class="math inline">16</span> 个值。从玩家 Alice
开始，一轮中的每个玩家选择棋盘的 <span class="math inline">2 × 2</span>
区域，将该区域中的值的总和添加到得分指示器，然后将这四个值逆时针旋转
<span class="math inline">90</span> 度。</p>
<p>在总共 <span class="math inline">2<em>k</em></span>
轮之后，每个玩家做了 <span class="math inline"><em>k</em></span>
次决定。 Alice的最终目标是最大化最终得分。然而对于 Bob
来说，他的目标是最小化最终得分。 <strong>sloution</strong> 对于 <span
class="math inline"><em>A</em><em>l</em><em>i</em><em>c</em><em>e</em></span>
- 需要保证答案最大 - 每步选择最大矩形，不能保证答案最大（不能贪心） -
所以现需要保证每次操作后，后续操作尽可能<strong>不小</strong>,也就是尽可能大
<span class="math inline"><em>B</em><em>o</em><em>b</em></span>同理</p>
<p><strong>如果 <span class="math inline"><em>k</em> = 1</span>
:</strong> A 会给 B 传入 <span class="math inline">9</span>
种矩形，且加上小矩形的和</p>
<p>然后 B 会从<strong>每个矩形</strong>中选择一个最小值返回</p>
<p>A 最终会选择 小矩形和 <span class="math inline">+</span>
B返回值最大的结果</p>
<p><strong>如果 <span
class="math inline"><em>k</em> ≥ 2</span>：</strong>
那么就是重复多次上述步骤，只是每次 B 会选择小矩形 <span
class="math inline">+</span> A返回值 最小的结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[x][y] + a[x<span class="number">+1</span>][y] + a[x][y<span class="number">+1</span>] + a[x<span class="number">+1</span>][y<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = a[x][y];</span><br><span class="line">	a[x][y] = a[x][y<span class="number">+1</span>];</span><br><span class="line">	a[x][y<span class="number">+1</span>] = a[x<span class="number">+1</span>][y<span class="number">+1</span>];</span><br><span class="line">	a[x<span class="number">+1</span>][y<span class="number">+1</span>] = a[x<span class="number">+1</span>][y];</span><br><span class="line">	a[x<span class="number">+1</span>][y] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rmove</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = a[x][y];</span><br><span class="line">	a[x][y] = a[x<span class="number">+1</span>][y];</span><br><span class="line">	a[x<span class="number">+1</span>][y] = a[x<span class="number">+1</span>][y<span class="number">+1</span>];</span><br><span class="line">	a[x<span class="number">+1</span>][y<span class="number">+1</span>] = a[x][y<span class="number">+1</span>];</span><br><span class="line">	a[x][y<span class="number">+1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p &gt; k*<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> res = (p&amp;<span class="number">1</span> ? <span class="number">0</span> : M);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tmp = <span class="built_in">get</span>(i,j);</span><br><span class="line">			<span class="built_in">move</span>(i,j);</span><br><span class="line">			res = (p&amp;<span class="number">1</span> ? <span class="built_in">max</span>(res,tmp+<span class="built_in">dfs</span>(p<span class="number">+1</span>)) : <span class="built_in">min</span>(res,tmp+<span class="built_in">dfs</span>(p<span class="number">+1</span>)));</span><br><span class="line">			<span class="built_in">rmove</span>(i,j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;++j)	cin &gt;&gt; a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举转移">枚举转移</h4>
<p><strong>题面</strong> 一串由0~9组成的数字，可以进行两个操作：
1、把其中一个数变为<strong>比它小</strong>的数；
2、把其中一个数字0及其右边的所以数字删除。</p>
<p>两人轮流进行操作，最后把所以数字删除的人获胜，问前者胜还是后者胜。
<strong>sloution</strong> 有 <span
class="math inline">$\sum_{i=1}^{6}(10^i)$</span> 种数字，若是使用
<code>dfs</code>或者说递归，每个状态都有<span
class="math inline">1 ∼ 9</span>条分支，且还是字符串形式，很容易
<code>TLE</code>。</p>
<p>但若是使用<strong>递推</strong>，只需要 <span
class="math inline">$\sum_{i=1}^{6}(10^i)$</span> 次。</p>
<p><strong>字符串的数据较多，所以使用数字存储</strong> &gt;
可能不需要，之前看错题导致出现很多错误 &gt;
但为了数字进位方便，还是用数字存储</p>
<ol type="1">
<li><strong>空字符串</strong>为 P态</li>
<li>数字无法存储前导0，且 0XXX 与 XXX 的结果不同</li>
<li>0XXX 可以一步到空字符串，也就是 N态，所以对其特判</li>
<li>其他数字按照组合游戏方法判断 PN 态。</li>
</ol>
<p>设 P 态为 <span class="math inline">1</span>， N 态为 <span
class="math inline">0</span>。 因为总状态 <span
class="math inline"> ≤ 10<sup>8</sup></span>打表计算后输出即可。</p>
<p><strong>code</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(N<span class="number">+10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	<span class="type">int</span> _ = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> z = <span class="number">0</span>;</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(z &lt;= N)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> op = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(z/op &gt;= <span class="number">10</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((z/op) % <span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(z/op) % <span class="number">10</span>;++i)	res |= a[z-op*i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	res |= a[z/(op*<span class="number">10</span>)];</span><br><span class="line">			op *= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		res |= <span class="number">0</span>;<span class="comment">// 不必要，代表0XXX</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;z/op;++i)	res |= a[z-op*i];<span class="comment">// 首位变成0 为 0XXX，而非XXX，所以去除掉</span></span><br><span class="line">		a[z] = !res;</span><br><span class="line">		z ++;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; _;</span><br><span class="line">	<span class="keyword">while</span>(_--)	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string st;</span><br><span class="line">	cin &gt;&gt; st;</span><br><span class="line">	<span class="keyword">if</span>(st[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)	cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span>	cout &lt;&lt; (a[<span class="built_in">stoi</span>(st)] ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### dp打表 <strong>题面</strong>
有一个01串。两个人在一起做游戏，ALICE先手，Bob后手，他们可以从以下两种操作中选一个：
1. 任选某个为0的位置将其变为1，代价为1。 2.
若该01串目前不为回文串，且上一个操作不为操作2的情况下可以将整个01串翻转。</p>
<p>代价少的人获胜，否则平局。 <strong>sloution</strong>
根据题意可知，字符的位置不重要，对称的关系才需要关注。</p>
<p>且如果对称位置为
<code>11</code>，那我就不需要再考虑了，因为无法再被修改。</p>
<p>所以可以可以记录每个状态为变为
(<code>00</code>,<code>11</code>,<code>mid</code>,<code>r_ed</code>)
分别是 <code>00</code>对的数目， <code>01</code>对的数目, 正中字符是
<code>1</code> 或 <code>0</code>，是否翻转过。</p>
<p>存储代价的最小值。因为值越小越可能赢</p>
<p>转移则看下列代码</p>
<p>对于每个状态，可以由至多四种可能转移而来 <strong>code</strong>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][N][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	<span class="type">int</span> _ = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp); </span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;++k)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&gt;=<span class="number">0</span>;--l)</span><br><span class="line">				&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span>) dp[i][j][k][l] = <span class="built_in">min</span>(dp[i][j][k][l],<span class="number">1</span>-dp[i<span class="number">-1</span>][j<span class="number">+1</span>][k][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">0</span>) dp[i][j][k][l] = <span class="built_in">min</span>(dp[i][j][k][l],<span class="number">1</span>-dp[i][j<span class="number">-1</span>][k][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(k==<span class="number">1</span>) dp[i][j][k][l] = <span class="built_in">min</span>(dp[i][j][k][l],<span class="number">1</span>-dp[i][j][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">if</span>(l==<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>) dp[i][j][k][l] = <span class="built_in">min</span>(dp[i][j][k][l],-dp[i][j][k][<span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; _;</span><br><span class="line">	<span class="keyword">while</span>(_--)	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	string st;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; st;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">	&#123;</span><br><span class="line">		a[<span class="number">0</span>] += (st[i] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; st[n-i<span class="number">-1</span>] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		a[<span class="number">1</span>] += st[i] != st[n-i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">2</span>] = (n&amp;<span class="number">1</span> &amp;&amp; st[n/<span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="type">int</span> z = dp[a[<span class="number">0</span>]][a[<span class="number">1</span>]][a[<span class="number">2</span>]][<span class="number">0</span>];</span><br><span class="line">	cout &lt;&lt; (z &lt; <span class="number">0</span> ? <span class="string">&quot;ALICE\n&quot;</span> : (z == <span class="number">0</span> ? <span class="string">&quot;DRAW\n&quot;</span> : <span class="string">&quot;BOB\n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="nim变体">Nim变体</h4>
<p><strong>题面</strong>
共有N堆石子，已知每堆中石子的数量，两个人轮流取石子，每次只能选择N堆石子中的一堆取一定数量的石子（最少取一个），取过子之后，还可以将该堆石子中剩余的石子随意选取几个放到其它的任意一堆或几堆上。等哪个人无法取子时就表示此人输掉了游戏。注意：一堆石子没有子之后，就不能再往此处放石子了。</p>
<p>假设每次都是小牛先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量，请判断出小牛能否获胜。
<strong>sloution</strong> |n|x|P-N| |-|-|-| |0|Null|P| |1|<span
class="math inline"><em>x</em></span>|N| |2|<span
class="math inline"><em>x</em><sub>1</sub> = <em>x</em><sub>2</sub></span></br><span
class="math inline"><em>x</em><sub>1</sub> &gt; <em>x</em><sub>2</sub></span>|P</br>N|
|3|<span
class="math inline"><em>x</em><sub>1</sub> ≥ <em>x</em><sub>2</sub> ≥ <em>x</em><sub>3</sub></span>|N|
|<span class="math inline">⋮</span>||| |<span
class="math inline">2 ⋅ <em>k</em> − 1</span>|<span
class="math inline"><em>x</em><sub>1</sub> ≥ <em>x</em><sub>2</sub>…<em>x</em><sub><em>n</em></sub></span>|N|
|<span class="math inline">2⋅</span>|<span
class="math inline"><em>x</em><sub>1</sub> = <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub> = <em>x</em><sub>4</sub></span></br>other|P</br>N|</p>
<blockquote>
<p>详细推导就不写了</p>
</blockquote>
<p><strong>对于 <span
class="math inline">2 ⋅ <em>k</em> − 1</span></strong> 保证一次变成
<span class="math inline">2 ⋅ <em>k</em></span> 且 <span
class="math inline"><em>x</em><sub>1</sub> = <em>x</em><sub>2</sub>…</span>
需要的代价是<span
class="math inline"><em>x</em><sub>2</sub> − <em>x</em><sub>3</sub> + <em>x</em><sub>4</sub> − <em>x</em><sub>5</sub> + … + <em>x</em><sub><em>n</em> − 1</sub> − <em>x</em><sub><em>n</em></sub></span>
<span
class="math inline">∵ − <em>x</em><sub>3</sub> + <em>x</em><sub>4</sub> ≤ 0, −<em>x</em><sub>5</sub> + <em>x</em><sub>6</sub> ≤ 0…</span>
且<span
class="math inline"><em>x</em><sub>2</sub> ≤ <em>x</em><sub>1</sub>, −<em>x</em><sub><em>n</em></sub> ≤ 0</span></p>
<p><span class="math inline">∴</span> 代价 <span
class="math inline"> ≤ <em>x</em><sub>1</sub></span>
<strong>code</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span>(!n)	<span class="keyword">break</span>;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)	cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Win\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(a.<span class="built_in">begin</span>()<span class="number">+1</span>,a.<span class="built_in">end</span>());</span><br><span class="line">		<span class="type">bool</span> op = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] != a[i<span class="number">+1</span>])	op = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; (op ? <span class="string">&quot;Lose\n&quot;</span> : <span class="string">&quot;Win\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sg函数-2">SG函数</h3>
<h4 id="模板题">模板题</h4>
<p><strong>题面</strong> 有一个 <span
class="math inline"><em>n</em></span> 个节点的有向无环图，编号为 <span
class="math inline">0</span> 到 <span
class="math inline"><em>n</em> − 1</span>。有若干轮游戏，每轮游戏给出
<span class="math inline"><em>m</em></span>
个棋子在图上的节点位置（可能存在多个棋子在同一个节点上）。两个玩家轮流移动棋子，每次可以选择一个棋子将其移动到它的后继节点。无法移动任何棋子的一方判输。假设双方都采取最优策略，如果先手获胜输出
<code>"WIN"</code>，否则输出 <code>"LOSE"</code>。
<strong>sloution</strong> 经典SG 使用 <code>记忆化搜索</code>
求出各点sg函数后，对每个回答求点的 <span class="math inline">⊕</span>
值即可。 <strong>code</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sg</span><span class="params">(N,<span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sg</span><span class="params">(<span class="type">int</span> p)</span><span class="comment">// 记忆化搜索求sg</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// if(p == 0)	return 0;</span></span><br><span class="line">	<span class="keyword">if</span>(sg[p] != <span class="number">-1</span>)	<span class="keyword">return</span> sg[p];</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : a[p])	st.<span class="built_in">insert</span>(<span class="built_in">get_sg</span>(i));</span><br><span class="line">	<span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">count</span>(mex))	<span class="keyword">return</span> (sg[p] = mex);</span><br><span class="line">		mex ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> k,x;	cin &gt;&gt; k;</span><br><span class="line">		<span class="comment">// if(k == 0)	sg[i] = 0;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;++j)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)	<span class="built_in">get_sg</span>(i);</span><br><span class="line">	<span class="comment">// get_sg(0);</span></span><br><span class="line">	<span class="type">int</span> m,tmp;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; m &amp;&amp; m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(m --)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; tmp;</span><br><span class="line">			ans ^= sg[tmp];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; (ans ? <span class="string">&quot;WIN&quot;</span> : <span class="string">&quot;LOSE&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ####
使用规律优化sg速度（减少递归） <strong>题面</strong> 有 <span
class="math inline"><em>n</em></span> 个箱子，第 <span
class="math inline"><em>i</em></span> 个箱子的容量为 <span
class="math inline"><em>s</em><sub><em>i</em></sub></span>，初始时装有
<span class="math inline"><em>c</em><sub><em>i</em></sub></span>
颗石子。两名玩家轮流往箱子里放石子，每次放入的石子数必须满足：<br />
<strong>放入的数量不超过当前箱子内石子数的平方</strong>（例如，若某箱子当前有
<span class="math inline">3</span> 颗石子，则可放入 <span
class="math inline">1</span> 到 <span class="math inline">9</span>
颗石子）。每次操作可以选择任意一个未满的箱子放入石子，直到某一方无法进行任何合法操作时判输。假设双方均采取最优策略，判断先手是否能获胜。若能获胜输出
<code>"YES"</code>，否则输出 <code>"NO"</code>。
<strong>sloution</strong> 到最后可以一步走到的点，可以直接得出其
g函数，而不需要再求 <span
class="math inline"><em>m</em><em>e</em><em>x</em></span>
<strong>code</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">65</span>)</span>, <span class="title">c</span><span class="params">(<span class="number">65</span>)</span>,<span class="title">g</span><span class="params">(N,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="comment">// vector&lt;vector&lt;int&gt;&gt; g(65,vector&lt;int&gt;(N,-1));</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sg</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p == s[k])	<span class="keyword">return</span> (g[p] = <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(g[p] != <span class="number">-1</span>)	<span class="keyword">return</span> g[p];</span><br><span class="line">	<span class="keyword">if</span>(p*(p<span class="number">+1</span>) &gt;= s[k])	<span class="keyword">return</span> s[k]-p;</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;p+i&lt;=s[k] &amp;&amp; i&lt;=p*p;++i)	st.<span class="built_in">insert</span>(<span class="built_in">get_sg</span>(k,p+i));</span><br><span class="line">	<span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">count</span>(mex))	<span class="keyword">return</span> (g[p] = mex);</span><br><span class="line">		mex ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; s[i] &gt;&gt; c[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=c[i];j&lt;=s[i];++j)	g[j] = <span class="number">-1</span>;</span><br><span class="line">		ans ^= <span class="built_in">get_sg</span>(i,c[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ans ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 分裂游戏（sg打表找规律）
<strong>题面</strong> Alice 和 Bob 厌倦了标准规则下的 Nim
游戏，因此他们修改了规则：允许玩家在每次操作时选择<strong>移除物品</strong>或<strong>将一堆分成两小堆</strong>。具体规则如下：
1. <strong>移除物品</strong>：从任意一堆中移除至少一个物品（规则与传统
Nim 相同）。 2.
<strong>分割堆</strong>：选择一堆，将其分成两堆较小的堆（堆的大小必须为正整数）。
游戏以正规则进行，即执行最后一次有效操作（移除最后一个物品或完成最后一次分割）的玩家获胜。
<strong>sloution</strong> <strong><span
class="math inline"><em>n</em></span>
很大时，sg函数只能作为打表的辅助，不能直接求解。</strong>
对于一组<strong>分裂游戏</strong>，虽然其可以分裂为多个子游戏，但是可以对其子游戏也求
Nim和，并作为更大单个游戏的子游戏，最后任可用sg函数求解。
<strong>code</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sg</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g[p] != <span class="number">-1</span>)	<span class="keyword">return</span> g[p];</span><br><span class="line">	unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p;++i)	st.<span class="built_in">insert</span>(<span class="built_in">get_sg</span>(i)); <span class="comment">// 取出</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;p;++i)	st.<span class="built_in">insert</span>(g[i]^g[p-i]);<span class="comment">// 分裂</span></span><br><span class="line">	<span class="type">int</span> mex = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">count</span>(mex))	<span class="keyword">return</span> (g[p] = mex);</span><br><span class="line">		mex ++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	<span class="type">int</span> _ = <span class="number">1</span>;</span><br><span class="line">	g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 调用sg打表</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;N;++i)	g[i] = -1;</span></span><br><span class="line">	<span class="comment">// for(int i=1;i&lt;N;++i)	get_sg(i);</span></span><br><span class="line">	cin &gt;&gt; _;</span><br><span class="line">	<span class="keyword">while</span>(_--)	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,x,ans = <span class="number">0</span>;	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span>(n --)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span>(x%<span class="number">4</span> == <span class="number">0</span>)	x --;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x%<span class="number">4</span> == <span class="number">3</span>)	x ++;</span><br><span class="line">		ans ^= x;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; (ans ? <span class="string">&quot;Alice\n&quot;</span> : <span class="string">&quot;Bob\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>博弈</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2025/09/17/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h2 id="线段树">线段树</h2>
<h3 id="模板">模板</h3>
<h4 id="区间修改线段树">区间修改线段树</h4>
<h5 id="区间和">区间和</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],t[N&lt;&lt;<span class="number">2</span>],lz[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 更新节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> z,<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] += (ed-be<span class="number">+1</span>) * z;</span><br><span class="line">	lz[p] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] = t[p&lt;&lt;<span class="number">1</span>] + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下放lazy_tag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update</span>(lz[p],be,mid,p&lt;&lt;<span class="number">1</span>),<span class="built_in">update</span>(lz[p],mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	lz[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p] = a[be];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> z,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(z,be,ed,p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	<span class="built_in">put</span>(l,r,z,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	<span class="built_in">put</span>(l,r,z,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> t[p];</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	res += <span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res += <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="区间rmq">区间RMQ</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],t[N&lt;&lt;<span class="number">2</span>],lz[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 更新节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> z,<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] += z;</span><br><span class="line">	lz[p] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] = <span class="built_in">max</span>(t[p&lt;&lt;<span class="number">1</span>],t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下放lazy_tag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update</span>(lz[p],be,mid,p&lt;&lt;<span class="number">1</span>),<span class="built_in">update</span>(lz[p],mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	lz[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p] = a[be];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> z,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(z,be,ed,p);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	<span class="built_in">put</span>(l,r,z,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	<span class="built_in">put</span>(l,r,z,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> t[p];</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	res = <span class="built_in">max</span>(res,<span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res = <span class="built_in">max</span>(res,<span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单点修改线段树">单点修改线段树</h4>
<p>单点修改不再需要lazy_tag <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],t[N&lt;&lt;<span class="number">2</span>],lz[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 更新节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> z,<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] += (ed-be<span class="number">+1</span>) * z;</span><br><span class="line">	lz[p] += z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] = t[p&lt;&lt;<span class="number">1</span>] + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下放lazy_tag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update</span>(lz[p],be,mid,p&lt;&lt;<span class="number">1</span>),<span class="built_in">update</span>(lz[p],mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	lz[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p] = a[be];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> z,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(z,be,ed,p);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	<span class="built_in">put</span>(l,r,z,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	<span class="built_in">put</span>(l,r,z,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> t[p];</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	res += <span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res += <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 权值线段树
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] = t[p&lt;&lt;<span class="number">1</span>] + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单点修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> v,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p] += v;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be+ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k &lt;= mid)	<span class="built_in">put</span>(k,v,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span>	<span class="built_in">put</span>(k,v,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询[l,r]内共有多少个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_cnt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> t[p];</span><br><span class="line">	<span class="type">int</span> mid = (be+ed) &gt;&gt; <span class="number">1</span>,cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	cnt += <span class="built_in">query_cnt</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	cnt += <span class="built_in">query_cnt</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询第 k 个数的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_k</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)	<span class="keyword">return</span> be;</span><br><span class="line">	<span class="type">int</span> mid = (be+ed) &gt;&gt; <span class="number">1</span>, lsum = t[p&lt;&lt;<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(lsum &gt;= k)	<span class="keyword">return</span> <span class="built_in">query_k</span>(k,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query_k</span>(k-lsum,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="多种-lazy_tag">多种 lazy_tag</h3>
<h4 id="乘法tag-和-加法tag">乘法tag 和 加法tag</h4>
<p><span
class="math inline">∑<em>x</em><em>a</em><sub><em>i</em></sub> + <em>b</em> = <em>x</em>∑<em>a</em><sub><em>i</em></sub> + <em>l</em><em>e</em><em>n</em> × <em>b</em></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum,mul,add;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="comment">// 更新节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> mul,<span class="type">int</span> add,<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].sum = t[p].sum*mul + (ed-be<span class="number">+1</span>) * add;</span><br><span class="line">	t[p].mul *= mul, t[p].add = t[p].add*mul+add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].sum = t[p&lt;&lt;<span class="number">1</span>].sum + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下放lazy_tag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update</span>(t[p].mul,t[p].add,be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">update</span>(t[p].mul,t[p].add,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	t[p].mul = <span class="number">1</span>, t[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].sum = a[be];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> add,<span class="type">int</span> mul,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(mul,add,be,ed,p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	<span class="built_in">put</span>(l,r,add,mul,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	<span class="built_in">put</span>(l,r,add,mul,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> t[p].sum;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	res += <span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res += <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 各种区间操作 #### 加上等差数列
方案很多，如果只需要单点信息，则可以只维护差分，这里只用一棵线段树维护。</p>
<p>一次增加操作被断开，视为两次增减操作即可。 - <span
class="math inline">[<em>l</em>, <em>x</em>]</span> 区间，<span
class="math inline"><em>k</em> + <em>i</em> × <em>d</em></span> - <span
class="math inline">[<em>x</em> + 1, <em>r</em>]</span> 区间，<span
class="math inline"><em>k</em> + <em>i</em> × (<em>x</em> + 1 − <em>l</em>) + <em>i</em> × <em>d</em></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	<span class="type">int</span> sum,k,d;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> d,<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = ed-be<span class="number">+1</span>;</span><br><span class="line">	t[p].sum += len*k + len*(len<span class="number">-1</span>)/<span class="number">2</span>*d;</span><br><span class="line">	t[p].k += k, t[p].d += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].sum = t[p&lt;&lt;<span class="number">1</span>].sum + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update</span>(t[p].k,t[p].d,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">update</span>(t[p].k+t[p].d*(mid<span class="number">+1</span>-be),t[p].d,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	t[p].k = t[p].d = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].sum = a[be];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> d,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(k+(be-l)*d,d,be,ed,p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	<span class="built_in">put</span>(l,r,k,d,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	<span class="built_in">put</span>(l,r,k,d,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> t[p].sum;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	res += <span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res += <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">put</span>(l,r,k,d);<span class="comment">// 给 l,r 加上以 k 为初始值, 方差为 d 的等差数列</span></span><br><span class="line"><span class="built_in">query</span>(l,r);<span class="comment">// l,r 区间和</span></span><br></pre></td></tr></table></figure></p>
<h3 id="各种区间信息">各种区间信息</h3>
<h4 id="区间平方和">区间平方和</h4>
<p><span
class="math inline">∑(<em>x</em><em>a</em><sub><em>i</em></sub> + <em>y</em>) = <em>x</em><sup>2</sup>∑<em>a</em><sub><em>i</em></sub><sup>2</sup> + 2<em>x</em><em>y</em>∑<em>a</em><sub><em>i</em></sub> + <em>l</em><em>e</em><em>n</em> × <em>y</em><sup>2</sup></span></p>
<p>需要维护区间和 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 区间和, 平方和, 加lz，乘lz</span></span><br><span class="line">	<span class="type">int</span> sum,sq,add,mul;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="comment">// 更新节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> mul,<span class="type">int</span> add,<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].sq = t[p].sq*mul*mul + t[p].sum*add*<span class="number">2</span> + (ed-be<span class="number">+1</span>)*add*add;</span><br><span class="line">	t[p].sum = t[p].sum*mul + (ed-be<span class="number">+1</span>) * add;</span><br><span class="line">	t[p].mul *= mul, t[p].add = t[p].add*mul+add;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].sum = t[p&lt;&lt;<span class="number">1</span>].sum + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	t[p].sq = t[p&lt;&lt;<span class="number">1</span>].sq + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下放lazy_tag</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update</span>(t[p].mul,t[p].add,be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">update</span>(t[p].mul,t[p].add,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	t[p].mul = <span class="number">1</span>, t[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p] = &#123;a[be],a[be]*a[be],<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> add,<span class="type">int</span> mul,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(mul,add,be,ed,p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	<span class="built_in">put</span>(l,r,add,mul,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	<span class="built_in">put</span>(l,r,add,mul,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> t[p].sq;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>,res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	res += <span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res += <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间乘</span></span><br><span class="line"><span class="built_in">put</span>(l,r,<span class="number">0</span>,x);</span><br><span class="line"><span class="comment">// 区间加</span></span><br><span class="line"><span class="built_in">put</span>(l,r,x,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="区间乘积和">区间乘积和</h4>
<p>求区间 <span class="math inline"><em>l</em></span> 到 <span
class="math inline"><em>r</em></span>
之间两两之间数字的乘积和(例如：<span
class="math inline">2, 3, 4, 5</span>两两之间乘积和为 <span
class="math inline">2 × 3 + 2 × 4 + 2 × 5 + 3 × 4 + 3 × 5 + 4 × 5</span>)</p>
<p><span
class="math inline">∑∑(<em>x</em><em>a</em><sub><em>i</em></sub> + <em>y</em>) × (<em>x</em><em>a</em><sub><em>j</em></sub> + <em>y</em>)</span>
<span
class="math inline"> = <em>x</em><sup>2</sup>∑∑<em>a</em><sub><em>i</em></sub><em>a</em><sub><em>j</em></sub> + <em>x</em><em>y</em>(<em>l</em><em>e</em><em>n</em> − 1)∑<em>a</em><sub><em>i</em></sub> + <em>l</em><em>e</em><em>n</em>(<em>l</em><em>e</em><em>n</em> − 1)<em>y</em><sup>2</sup>/2</span></p>
<p>需要维护区间和 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 区间和，区间乘积和，乘法lz，加法lz</span></span><br><span class="line">	<span class="type">int</span> sum,ab,mul,add;</span><br><span class="line">&#125;t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,P;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> mul,<span class="type">int</span> add,<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> L = ed-be<span class="number">+1</span>;</span><br><span class="line">	<span class="comment">// 切记先算乘积和，因为其依托于区间和</span></span><br><span class="line">	t[p].ab = ((t[p].ab*mul*mul + (L<span class="number">-1</span>)*mul*add*t[p].sum) + L*(L<span class="number">-1</span>)/<span class="number">2</span>*add*add);</span><br><span class="line">	t[p].sum = (t[p].sum*mul + L*add);</span><br><span class="line">	t[p].mul = t[p].mul*mul;</span><br><span class="line">	t[p].add = (t[p].add*mul + add);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p].sum = (t[p&lt;&lt;<span class="number">1</span>].sum + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum);</span><br><span class="line">	t[p].ab = ((t[p&lt;&lt;<span class="number">1</span>].ab + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ab) + t[p&lt;&lt;<span class="number">1</span>].sum*t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下放懒标记</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t[p].mul == <span class="number">1</span> &amp;&amp; t[p].add == <span class="number">0</span>)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update</span>(t[p].mul,t[p].add,be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">update</span>(t[p].mul,t[p].add,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	t[p].mul = <span class="number">1</span>,t[p].add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] = &#123;a[be],<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].sum = a[be];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>), <span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> mul,<span class="type">int</span> add,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(mul,add,be,ed,p);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	<span class="built_in">put</span>(l,r,mul,add,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	<span class="built_in">put</span>(l,r,mul,add,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function">PII <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> &#123;t[p].sum,t[p].ab&#125;;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	PII res = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)</span><br><span class="line">	&#123;</span><br><span class="line">		res = <span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)</span><br><span class="line">		&#123;</span><br><span class="line">			PII tmp = <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">			res.Y = (res.Y+tmp.Y) + res.X*tmp.X;</span><br><span class="line">			res.X = res.X+tmp.X;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res = <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">put</span>(l,r,<span class="number">1</span>,v);<span class="comment">// 区间加</span></span><br><span class="line"><span class="built_in">put</span>(l,r,v,<span class="number">0</span>);<span class="comment">// 区间乘</span></span><br></pre></td></tr></table></figure></p>
<h3 id="区间信息性质">区间信息性质</h3>
<h4 id="开方性质">开方性质</h4>
<p>一个 <span class="math inline"> ≤ 10<sup>9</sup></span>
的数，最多<strong>五次</strong>开方到 <span class="math inline">1</span>
&gt; 就是 <span class="math inline"> ≤ 10<sup>18</sup></span>
的数，也只需要 <strong>六次</strong></p>
<p><strong>题面:</strong> 第一行一个整数 <span
class="math inline"><em>n</em></span>，代表数列中数的个数。</p>
<p>第二行 <span class="math inline"><em>n</em></span>
个正整数，表示初始状态下数列中的数。</p>
<p>第三行一个整数 <span class="math inline"><em>m</em></span>，表示有
<span class="math inline"><em>m</em></span> 次操作。</p>
<p>接下来 <span class="math inline"><em>m</em></span> 行每行三个整数
<code>k l r</code>。</p>
<ul>
<li><span class="math inline"><em>k</em> = 0</span> 表示给 <span
class="math inline">[<em>l</em>, <em>r</em>]</span>
中的每个数开平方（下取整）。</li>
<li><span class="math inline"><em>k</em> = 1</span> 表示询问 <span
class="math inline">[<em>l</em>, <em>r</em>]</span> 中各个数的和。</li>
</ul>
<p><strong>思路:</strong> 一个 <span class="math inline">≥</span> 的数,
最多 <span class="math inline">5</span> 次开方变成 <span
class="math inline">1</span>, 所以最多对所有数 <span
class="math inline">5</span> 次单点修改.
那么只需要维护<strong>单点修改</strong>和<strong>区间查询</strong>.
并且维护区间最值, 最大值为 <span class="math inline">1</span>,
则无需再修改. <strong>代码:</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Start cin.tie(0), cout.tie(0), ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(N)</span>,<span class="title">t</span><span class="params">(N&lt;&lt;<span class="number">2</span>)</span>,<span class="title">tmx</span><span class="params">(N&lt;&lt;<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t[p] = t[p&lt;&lt;<span class="number">1</span>] + t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">	tmx[p] = <span class="built_in">max</span>(tmx[p&lt;&lt;<span class="number">1</span>],tmx[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p] = a[be];</span><br><span class="line">		tmx[p] = a[be];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>),<span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p] = <span class="built_in">sqrt</span>(t[p]);</span><br><span class="line">		tmx[p] = <span class="built_in">sqrt</span>(tmx[p]);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid &amp;&amp; tmx[p] &gt; <span class="number">1</span>)	<span class="built_in">put</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r &amp;&amp; tmx[p] &gt; <span class="number">1</span>)	<span class="built_in">put</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)	<span class="keyword">return</span> t[p];</span><br><span class="line">	<span class="type">int</span> mid = (be + ed) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	res += <span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res += <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	<span class="type">int</span> _ = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; _;</span></span><br><span class="line">	<span class="keyword">while</span>(_--)	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)	cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">build_tree</span>();</span><br><span class="line">	cin &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> op;	cin &gt;&gt; op;</span><br><span class="line">		<span class="type">int</span> l,r;	cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="keyword">if</span>(l &gt; r)	<span class="built_in">swap</span>(l,r);</span><br><span class="line">		<span class="keyword">if</span>(op)	cout &lt;&lt; <span class="built_in">query</span>(l,r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span>	<span class="built_in">put</span>(l,r);<span class="comment">// 一次结束当然比循环一次要快了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="开多棵线段树">开多棵线段树</h3>
<p><strong>此处是bitset优化</strong> <strong>题面:</strong> 色板长度为
<span class="math inline"><em>L</em></span>，<span
class="math inline"><em>L</em></span>
是一个正整数，所以我们可以均匀地将它划分成 <span
class="math inline"><em>L</em></span> 块 <span
class="math inline">1</span> 厘米长的小方格。并从左到右标记为 <span
class="math inline">1, 2, …<em>L</em></span>。</p>
<p>现在色板上只有一个颜色，老师告诉阿宝在色板上只能做两件事：</p>
<ol type="1">
<li><code>C A B C</code> 指在 <span
class="math inline"><em>A</em></span> 到 <span
class="math inline"><em>B</em></span> 号方格中涂上颜色 <span
class="math inline"><em>C</em></span>。</li>
<li><code>P A B</code> 指老师的提问：<span
class="math inline"><em>A</em></span> 到 <span
class="math inline"><em>B</em></span> 号方格中有几种颜色。</li>
</ol>
<p>学校的颜料盒中一共有 <span class="math inline"><em>T</em></span>
种颜料。为简便起见，我们把他们标记为 <span
class="math inline">1, 2, …<em>T</em></span>. 开始时色板上原有的颜色就为
<span class="math inline">1</span> 号色。
面对如此复杂的问题，阿宝向你求助，你能帮助他吗？</p>
<p><strong>输入格式:</strong> 第一行有3个整数 <span
class="math inline"><em>L</em>(1 ≤ <em>L</em> ≤ 10<sup>5</sup>), <em>T</em>(1 ≤ <em>T</em> ≤ 30)<em>和</em><em>O</em>(1 ≤ <em>O</em> ≤ 10<sup>5</sup>)</span>。
在这里 <span class="math inline"><em>O</em></span> 表示事件数。</p>
<p>接下来 <span class="math inline"><em>O</em></span> 行, 每行以
<code>C A B C</code> 或 <code>P A B</code> 得形式表示所要做的事情（这里
<span class="math inline"><em>A</em>, <em>B</em>, <em>C</em></span>
为整数, 可能 <span
class="math inline"><em>A</em> &gt; <em>B</em></span>，这样的话需要你交换
<span class="math inline"><em>A</em></span> 和 <span
class="math inline"><em>B</em></span>）。 <strong>输出格式:</strong>
对于老师的提问，做出相应的回答。每行一个整数。</p>
<p><strong>代码:</strong> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Start cin.tie(0), cout.tie(0), ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k,q;</span><br><span class="line">vector&lt;bitset&lt;1000&gt;&gt; <span class="built_in">t</span>(N&lt;&lt;<span class="number">2</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lz</span><span class="params">(N&lt;&lt;<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// vector&lt;vector&lt;bool&gt;&gt; t(40,vector&lt;bool&gt;(N&lt;&lt;2));</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; lz(N&lt;&lt;2);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> col,<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; col &lt;&lt; &#x27; &#x27; &lt;&lt; be &lt;&lt; &#x27; &#x27; &lt;&lt; ed &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	t[p].<span class="built_in">reset</span>();	t[p].<span class="built_in">set</span>(col);</span><br><span class="line">	lz[p] = col;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> lp = p&lt;&lt;<span class="number">1</span>, rp = p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>;</span><br><span class="line">	t[p] = t[p&lt;&lt;<span class="number">1</span>] | t[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> be,<span class="type">int</span> ed,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lz[p] == <span class="number">0</span>)	<span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> mid = (be+ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">update</span>(lz[p],be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">update</span>(lz[p],mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	lz[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_tree</span><span class="params">(<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be == ed)</span><br><span class="line">	&#123;</span><br><span class="line">		t[p].<span class="built_in">set</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (be+ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build_tree</span>(be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">build_tree</span>(mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> col,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">update</span>(col,be,ed,p);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be+ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	<span class="built_in">put</span>(l,r,col,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	<span class="built_in">put</span>(l,r,col,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">	<span class="comment">// cout &lt;&lt; t[col][p] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bitset&lt;1000&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> be=<span class="number">1</span>,<span class="type">int</span> ed=n,<span class="type">int</span> p=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	bitset&lt;1000&gt; res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= be &amp;&amp; ed &lt;= r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> t[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(be,ed,p);</span><br><span class="line">	<span class="type">int</span> mid = (be+ed) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l &lt;= mid)	res |= <span class="built_in">query</span>(l,r,be,mid,p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mid<span class="number">+1</span> &lt;= r)	res |= <span class="built_in">query</span>(l,r,mid<span class="number">+1</span>,ed,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Start;</span><br><span class="line">	<span class="type">int</span> _  = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(_--)	<span class="built_in">func</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k &gt;&gt; q;</span><br><span class="line">	<span class="built_in">build_tree</span>();</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		<span class="type">int</span> l,r;</span><br><span class="line">		cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="keyword">if</span>(l &gt; r)	<span class="built_in">swap</span>(l,r);</span><br><span class="line">		<span class="keyword">if</span>(op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> col;	cin &gt;&gt; col;</span><br><span class="line">			<span class="built_in">put</span>(l,r,col);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			cout &lt;&lt; <span class="built_in">query</span>(l,r).<span class="built_in">count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="comment">// cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>数据结构</category>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>非自动机字符串算法</title>
    <url>/2025/09/17/%E9%9D%9E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="基础概念">基础概念</h2>
<h3 id="border">border</h3>
<p>如果字符串 <span class="math inline"><em>S</em></span>
的同长度的前后缀完全相同，则称此前后缀为一个 <span
class="math inline"><em>B</em><em>o</em><em>r</em><em>d</em><em>e</em><em>r</em></span>，也可以指这个
<span
class="math inline"><em>B</em><em>o</em><em>r</em><em>d</em><em>e</em><em>r</em></span>
的长度</p>
<h3 id="周期和循环节">周期和循环节</h3>
<p>如果一个字符串 <span class="math inline"><em>Z</em></span> 在 <span
class="math inline"><em>S</em></span> 中循环出现 -
如果可能不完整出现，则为循环周期 - 如果完整出现，则为循环节</p>
<h3 id="border-性质">border 性质</h3>
<p><strong>周期定理：</strong> 若 <span
class="math inline"><em>p</em>, <em>q</em></span> 为 <span
class="math inline"><em>S</em></span> 的周期，则 <span
class="math inline">gcd (<em>p</em>, <em>q</em>)</span> 也为 <span
class="math inline"><em>S</em></span> 的周期。
<strong>等差数列：</strong> 一个串的 border 数量是 <span
class="math inline">(<em>n</em>)</span> 个，但他们组成了 <span
class="math inline"><em>O</em>(log <em>n</em>)</span> 个等差数列</p>
<h3 id="border-树">border 树</h3>
<p><span class="math inline"><em>i</em></span> 的父亲为 <span
class="math inline"><em>n</em><em>x</em><em>t</em><sub><em>i</em></sub></span>
构成的一棵树（包括 <span class="math inline">0</span>，<span
class="math inline">0</span> 为根节点）</p>
<p><strong>性质：</strong> - 每个前缀 <span
class="math inline"><em>p</em><em>r</em><em>e</em><sub><em>i</em></sub></span>
的所有 border 为节点 <span class="math inline"><em>i</em></span>
到根的链 - <span class="math inline"><em>x</em></span> 的子树有长度为
<span class="math inline"><em>x</em></span> 的 border - 求两个前缀的公共
border 等价于求 <span
class="math inline"><em>l</em><em>c</em><em>a</em></span></p>
<h3 id="广义border">广义border</h3>
<p>对于字典 <span class="math inline"><em>D</em></span> 和串 <span
class="math inline"><em>S</em></span>，相等长度的 <span
class="math inline"><em>S</em></span> 后缀和任意一个字典串 <span
class="math inline"><em>T</em></span> 的前缀称为一个border</p>
<h3 id="失配指针">失配指针</h3>
<p>类似 KMP的border，任意节点的
border长度减一，一点是父节点的border。银川可以通过遍历父节点的失配指针链求解。</p>
<p>因此在求失配指针的时候，一定要按长度从小到大求，即<strong>bfs</strong></p>
<p>复杂度线性，用类似势能分析来求。</p>
<h2 id="字符串hash">字符串Hash</h2>
<h3 id="概念">概念</h3>
<p>哈希：一种单射函数，可以将<strong>万物</strong>映射为一个整数值。
<strong>字符串哈希：</strong>
将一个字符串映射为一个整数值的方法，<u>通常用来比较两个字符串是否相等</u></p>
<p><strong>性质：</strong> - <strong>必要性：</strong> 若字符串 <span
class="math inline"><em>S</em> = <em>T</em></span>，则 <span
class="math inline"><em>H</em>(<em>S</em>) = <em>H</em>(<em>T</em>)</span>
- <strong>非</strong>充分性：若 <span
class="math inline"><em>H</em>(<em>S</em>) = <em>H</em>(<em>T</em>)</span>，<strong>不一定</strong>
<span class="math inline"><em>S</em> = <em>T</em></span>
(可以实现，但不要求)</p>
<p><strong>Hash检测：</strong> 通过检测 <span
class="math inline"><em>H</em>(<em>S</em>)</span> 和 <span
class="math inline"><em>H</em>(<em>T</em>)</span> 是否相等，来判断 <span
class="math inline"><em>S</em></span> 和 <span
class="math inline"><em>T</em></span> 是否相等的方法。
<strong>Hash冲突：</strong> <span
class="math inline"><em>H</em>(<em>S</em>) = <em>H</em>(<em>T</em>)</span>
时，但 <span
class="math inline"><em>S</em> ≠ <em>T</em></span>，则称发生了Hash冲突
&gt; Hash 检测时 Hash 冲突的概率是衡量 Hash 算法好坏的重要指标 &gt;&gt;
比如冲突概率 <span class="math inline"> ≤ 10<sup>−4</sup></span></p>
<h3 id="多项式取模哈希">多项式取模哈希</h3>
<h4 id="多项式-hash">多项式 Hash</h4>
<p>将字符串看作某个进制 (Base) 下的数字串(类似直接
<code>stoi()</code>，只是进制不同)</p>
<p><span class="math inline">$H(S) = \sum s_i \times {Base}^{1+n-i} =
\bf{H(S[1,|S|-1]) \times Base + S[|H|]}$</span> $ = S_1 Bash^{n-1} + S_2
Base^{n-2} + + S_n Base^0$</p>
<p><strong>优点：</strong> 字符串和 Hash
值一一对应，<strong>不会</strong>产生Hash冲突，且利用率高
<strong>缺点：</strong> 数字范围过大，难以用原始数据存储和比较</p>
<h4 id="多项式取模-hash模哈">多项式取模 Hash（模哈）</h4>
<p>为了解决多项式 Hash 值域过大的问题，在效率和冲突率中的折中。</p>
<p>将 Hash 值对一个较大的质数取模</p>
<p><span class="math inline">$H'(S) = H(S) \\% mod$</span></p>
<p><strong>优点：</strong> 使得Hash值可以用
<code>uint</code>/<code>ulong</code> 存储和比较 <strong>缺点：</strong>
小概率 Hash 冲突</p>
<p>因为当检验次数 <span class="math inline">$\ge
\sqrt{mod}$</span>，有较大概率发生错误。
<strong>为了保证冲突率低，模哈使用的 <span
class="math inline"><em>m</em><em>o</em><em>d</em></span> 最好超过 Hash
检测次数的平方</strong></p>
<h4 id="hash-模数">Hash 模数</h4>
<p>优秀的 Hash 模数首先应满足：<strong>足够大</strong></p>
<p><strong>自然溢出：</strong> 使用 <code>ULL</code> 保存Hash值，溢出
<code>ULL</code>，等同于 <span class="math inline">$\\%
2^{64}$</span>(很容易卡)</p>
<p>优秀的模数还一个是一个 <strong>质数</strong></p>
<p><strong>质数单模：</strong> 选取<strong>一个</strong><span
class="math inline">10<sup>9</sup> ∼ 10<sup>10</sup></span>
的大质数，但是有 <strong>广为人知</strong> 的方法构造冲突。 &gt;
如果在int内更多，会更有优势 (在32位计算机上)</p>
<p><strong>双模：</strong>
进行多次不同质数的单模哈希，冲突概率为各次单模的概率乘积 &gt;
在不泄露模数的情况下，没有已知方法可以构造冲突</p>
<h5 id="快速求子串-hash">快速求子串 hash</h5>
<p><span class="math inline">$H(S) = (S_l \times Bash^{r-l} + S_{l+1}+1
\times Base^{r-l-1} + \cdots + S_r)\\% mod$</span></p>
<p>$F(i ) = H ( pre_{i}) $</p>
<p><span class="math inline">$F(l-1) = (S_1 \times Bash^{ l-2} + S_{2}
\times Base^{l-3} + \cdots + S_{l-1}) \\% mod$</span></p>
<p><span class="math inline">$F(r) = (S_1 \times Bash^{r-1} + S_{2}
\times Base^{r-2} + \cdots + S_{r}) \\% mod$</span></p>
<p><span
class="math inline">∴ <em>H</em>(<em>S</em>[<em>l</em>, <em>r</em>]) = <em>F</em>(<em>r</em>) − <em>F</em>(<em>l</em> − 1) × <em>B</em><em>a</em><em>s</em><em>e</em><sup><em>r</em> − <em>l</em> + 1</sup></span></p>
<h4 id="回文串hash性质">回文串hash性质</h4>
<p>对于回文串，正向Hash和反向Hash值是一样的</p>
<h4 id="code">code</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">26</span>;</span><br><span class="line">PII mod = &#123;<span class="number">1000000321</span>,<span class="number">1000000711</span>&#125;;<span class="comment">// 模数，随便塞两个素数也行</span></span><br><span class="line">string st;<span class="comment">// 哈希字符串</span></span><br><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">s</span><span class="params">(N)</span></span>;<span class="comment">// 前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string &amp;st,vector&lt;PII&gt; &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> L = st.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s[i].X = (s[i<span class="number">-1</span>].X * base) % mod.X;</span><br><span class="line">		s[i].X = (s[i].X + st[i]-<span class="string">&#x27;a&#x27;</span>)%mod.X;</span><br><span class="line">		s[i].Y = (s[i<span class="number">-1</span>].Y * base) % mod.Y;</span><br><span class="line">		s[i].Y = (s[i].Y + st[i]-<span class="string">&#x27;a&#x27;</span>)%mod.X;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">PII <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PII res = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	res.X = (s[r].X - s[l<span class="number">-1</span>].X*<span class="built_in">qpow</span>(base,r-l<span class="number">+1</span>,mod.X));</span><br><span class="line">	res.Y = (s[r].Y - s[l<span class="number">-1</span>].Y*<span class="built_in">qpow</span>(base,r-l<span class="number">+1</span>,mod.Y));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kmp">KMP</h2>
<h3 id="模板">模板</h3>
<p>求 border + kmp查找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 2 开始</span></span><br><span class="line">string st;<span class="comment">// 模式串</span></span><br><span class="line">string s;<span class="comment">// 查找串</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string &amp;st)</span><span class="comment">// 求border</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=st.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nxt[i] = nxt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">while</span>(nxt[i] &amp;&amp; st[nxt[i]<span class="number">+1</span>] != st[i])  nxt[i] = nxt[nxt[i]];</span><br><span class="line">        nxt[i] += st[nxt[i]<span class="number">+1</span>] == st[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,string&amp; s)</span><span class="comment">// 求第一个匹配的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; st[j<span class="number">+1</span>] != s[i])   j = nxt[j];</span><br><span class="line">        j += (st[j<span class="number">+1</span>] == s[i]);</span><br><span class="line">        <span class="keyword">if</span>(j == m)  <span class="keyword">return</span> i-j<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,string&amp; s)</span><span class="comment">// 求匹配的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; st[j<span class="number">+1</span>] != s[i])   j = nxt[j];</span><br><span class="line">        j += (st[j<span class="number">+1</span>] == s[i]);</span><br><span class="line">        <span class="keyword">if</span>(j == m)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            j = nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目">题目</h3>
<h4 id="串合并去重">串合并去重</h4>
<p>需要合并 <span class="math inline"><em>a</em></span> 和 <span
class="math inline"><em>b</em></span>，并去除两者间公共部分。</p>
<p>只需要对 <span class="math inline"><em>b</em></span>
新建border数组，然后用 <span class="math inline"><em>a</em></span>
最后长度等于 <span class="math inline"><em>b</em></span>
的部分进行匹配，匹配的最大长度及公共部分</p>
<p>对于 <span class="math inline"><em>n</em></span> 个串首尾相接
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line">string s0,st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cin &gt;&gt; s0;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; st;</span><br><span class="line">		st = <span class="string">&#x27;_&#x27;</span> + st;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;st.<span class="built_in">size</span>();++j)</span><br><span class="line">		&#123;</span><br><span class="line">			nxt[j] = nxt[j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">while</span>(nxt[j] &amp;&amp; st[j] != st[nxt[j]<span class="number">+1</span>])	nxt[j] = nxt[nxt[j]];</span><br><span class="line">			nxt[j] += (st[j] == st[nxt[j]<span class="number">+1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> be = (s<span class="number">0.</span><span class="built_in">size</span>() &gt;= st.<span class="built_in">size</span>()<span class="number">-1</span> ? s<span class="number">0.</span><span class="built_in">size</span>()-st.<span class="built_in">size</span>()<span class="number">+1</span> : <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=be;j&lt;s<span class="number">0.</span><span class="built_in">size</span>();++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(p&gt;<span class="number">0</span> &amp;&amp; st[p<span class="number">+1</span>] != s0[j])	p = nxt[p];</span><br><span class="line">			<span class="keyword">if</span>(st[p<span class="number">+1</span>] == s0[j])	p ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=p<span class="number">+1</span>;j&lt;st.<span class="built_in">size</span>();++j)	s0 += st[j];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; s0 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="反复删除子串">反复删除子串</h4>
<p>每次删除第一次出现的要求子串</p>
<p>存储各个位置匹配的最大长度，匹配满后跳跃到对应位置可直接从border中匹配
&gt; <code>string.erase()</code>
貌似很慢，但是好像都不会tle，为防万一可以用栈存储。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string s,t;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	<span class="type">int</span> ls = s.<span class="built_in">size</span>(), lt = t.<span class="built_in">size</span>();</span><br><span class="line">	t = <span class="string">&#x27;_&#x27;</span> + t;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(lt<span class="number">+1</span>)</span>,<span class="title">p</span><span class="params">(ls<span class="number">+1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=lt;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		nxt[i] = nxt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span>(nxt[i] &amp;&amp; t[i] != t[nxt[i]<span class="number">+1</span>])	 nxt[i] = nxt[nxt[i]];</span><br><span class="line">		nxt[i] += (t[i] == t[nxt[i]<span class="number">+1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; t[j<span class="number">+1</span>] != s[i])	j = nxt[j];</span><br><span class="line">		<span class="keyword">if</span>(t[j<span class="number">+1</span>] == s[i])	j ++;</span><br><span class="line">		p[i] = j;</span><br><span class="line">		<span class="keyword">if</span>(j == lt)</span><br><span class="line">		&#123;</span><br><span class="line">			j = (i &gt;= lt ? p[i-lt] : <span class="number">0</span>);</span><br><span class="line">			i -= lt;</span><br><span class="line">			s.<span class="built_in">erase</span>(i<span class="number">+1</span>,lt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i &gt;= <span class="number">0</span>)	p[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求最长真周期">求最长真周期</h4>
<p>根据性质：周期 <span
class="math inline"> = |<em>S</em>|−<em>b</em><em>o</em><em>r</em><em>d</em><em>e</em><em>r</em></span>
最长<strong>真</strong>周期则用最短 broder，用dfs传递最短border即可。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&gt; 这道题求最长真周期和</span><br><span class="line"><span class="type">int</span> n,nxt[N];</span><br><span class="line">string st;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!t)	t = nxt[p];</span><br><span class="line">	ans += (t ? p-t : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : v[p])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(i,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; st;</span><br><span class="line">	st = <span class="string">&#x27;_&#x27;</span> + st;</span><br><span class="line">	v[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		nxt[i] = nxt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span>(nxt[i] &amp;&amp; st[i] != st[nxt[i]<span class="number">+1</span>])	nxt[i] = nxt[nxt[i]];</span><br><span class="line">		nxt[i] += (st[i] == st[nxt[i]<span class="number">+1</span>]);</span><br><span class="line">		v[nxt[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>,nxt[<span class="number">0</span>]);</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="求不重叠border数目">求不重叠border数目</h4>
<p>求各个前缀长度 <span class="math inline"> ≤ <em>S</em>/2</span>
的border数目</p>
<p>用dp存储各个串的border数目，每次将前方 <span
class="math inline"><em>T</em> ≤ <em>S</em>/2</span> 的dp加入答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line">string st;</span><br><span class="line"><span class="type">int</span> nxt[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; st;</span><br><span class="line">	n = st.<span class="built_in">size</span>(),ans = <span class="number">1</span>;</span><br><span class="line">	st = <span class="string">&#x27;_&#x27;</span> + st;</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		nxt[i] = nxt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">while</span>(nxt[i] &amp;&amp; st[i] != st[nxt[i]<span class="number">+1</span>])	nxt[i] = nxt[nxt[i]];</span><br><span class="line">		nxt[i] += (st[i] == st[nxt[i]<span class="number">+1</span>]);</span><br><span class="line">		<span class="keyword">if</span>(nxt[i])	dp[i] = dp[nxt[i]] + <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; dp[i] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> p = nxt[i];</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">		<span class="keyword">while</span>(p*<span class="number">2</span> &gt; i)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp.<span class="built_in">push_back</span>(p);</span><br><span class="line">			p = nxt[p];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : tmp)	nxt[i] = p;</span><br><span class="line">		<span class="keyword">if</span>(p)	ans = ans*(dp[p]<span class="number">+2</span>)%M;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="trie">trie</h2>
<h3 id="模板-1">模板</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> idx,nxt[N],ext[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string &amp;st,<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	ext[p] = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(string &amp;st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st.<span class="built_in">size</span>();++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> c = st[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!nxt[p][c])	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		p = nxt[p][c];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ext[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目-1">题目</h3>
<h4 id="字符串子串插入">字符串子串插入</h4>
<p>需要插入反复插入一个字符串的子串或者部分，每次不能新建整个串，而是从上次插入地方继续加入节点
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : s0)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i == <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(st.<span class="built_in">size</span>())	st.<span class="built_in">erase</span>(st.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">		p = fa[p];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="string">&#x27;P&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j : st)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> c = j-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(!nxt[p][c])	nxt[p][c] = ++ idx;</span><br><span class="line">			trie[p][c] = nxt[p][c];</span><br><span class="line">			fa[nxt[p][c]] = p;</span><br><span class="line">			p = nxt[p][c];</span><br><span class="line">		&#125;</span><br><span class="line">		mp[++ cnt] = p;</span><br><span class="line">		st.<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	st += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>ACM</category>
        <category>string</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>string</tag>
      </tags>
  </entry>
</search>
